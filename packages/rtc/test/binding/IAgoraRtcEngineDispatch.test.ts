/// Generated by terra, DO NOT MODIFY BY HAND.

import * as NATIVE_RTC from '@iris/native-rtc-binding';
import { CallIrisApiResult, IrisApiEngine, IrisCore } from 'iris-web-core';

import { IrisWebRtc } from '../../src/IrisRtcApi';
import { IrisRtcEngine } from '../engine/IrisRtcEngine';

const bindingAPI = require('../../src/binding/IAgoraRtcEngineDispatch');

let apiEnginePtr: IrisApiEngine;
let irisRtcEngine: IrisRtcEngine;
beforeAll(async () => {
  apiEnginePtr = IrisCore.createIrisApiEngine();
  IrisWebRtc.initIrisRtc(apiEnginePtr);
  irisRtcEngine = apiEnginePtr['apiInterceptors'][0];
  irisRtcEngine.implHelper.createAudioTrack = jest.fn();
  let nParam = {
    context: 'test',
  };
  let apiParam = new IrisCore.EventParam(
    'RtcEngine_initialize',
    JSON.stringify(nParam),
    0,
    '',
    ['test'],
    [],
    1
  );
  await IrisCore.callIrisApi(apiEnginePtr, apiParam);
});

afterAll(() => {
  IrisCore.disposeIrisApiEngine(apiEnginePtr);
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('IRtcEngineEventHandler', () => {
  test('onJoinChannelSuccess impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onJoinChannelSuccess(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRejoinChannelSuccess impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRejoinChannelSuccess(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onProxyConnected impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onProxyConnected(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onError(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onError');
  });
  test('onAudioQuality impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioQuality(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLastmileProbeResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLastmileProbeResult(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioVolumeIndication impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioVolumeIndication(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLeaveChannel impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLeaveChannel(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRtcStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtcStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioDeviceStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onAudioDeviceStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onAudioDeviceStateChanged');
  });
  test('onAudioMixingPositionChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioMixingPositionChanged(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioMixingFinished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioMixingFinished();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioEffectFinished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onAudioEffectFinished(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onAudioEffectFinished');
  });
  test('onVideoDeviceStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onVideoDeviceStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onVideoDeviceStateChanged');
  });
  test('onNetworkQuality impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onNetworkQuality(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onNetworkQuality');
  });
  test('onIntraRequestReceived impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onIntraRequestReceived();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUplinkNetworkInfoUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUplinkNetworkInfoUpdated(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onDownlinkNetworkInfoUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onDownlinkNetworkInfoUpdated(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLastmileQuality impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLastmileQuality(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstLocalVideoFrame impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onFirstLocalVideoFrame(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onFirstLocalVideoFrame');
  });
  test('onFirstLocalVideoFramePublished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstLocalVideoFramePublished(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstRemoteVideoDecoded impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteVideoDecoded(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onVideoSizeChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoSizeChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLocalVideoStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onLocalVideoStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onLocalVideoStateChanged');
  });
  test('onRemoteVideoStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoStateChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstRemoteVideoFrame impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteVideoFrame(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserJoined impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserJoined(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserOffline impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserOffline(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserMuteAudio impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserMuteAudio(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserMuteVideo impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserMuteVideo(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserEnableVideo impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserEnableVideo(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserEnableLocalVideo impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserEnableLocalVideo(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLocalAudioStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalAudioStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteAudioStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLocalVideoStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalVideoStats(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteVideoStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onCameraReady impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onCameraReady();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onCameraFocusAreaChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onCameraFocusAreaChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onCameraExposureAreaChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onCameraExposureAreaChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFacePositionChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFacePositionChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onVideoStopped impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoStopped();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioMixingStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioMixingStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRhythmPlayerStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRhythmPlayerStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onConnectionLost impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionLost();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onConnectionInterrupted impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionInterrupted();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onConnectionBanned impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionBanned();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onStreamMessage impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onStreamMessage(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onStreamMessageError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onStreamMessageError(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRequestToken impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRequestToken();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onTokenPrivilegeWillExpire impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onTokenPrivilegeWillExpire(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLicenseValidationFailure impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLicenseValidationFailure(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstLocalAudioFramePublished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstLocalAudioFramePublished(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstRemoteAudioFrame impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteAudioFrame(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstRemoteAudioDecoded impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteAudioDecoded(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLocalAudioStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onLocalAudioStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onLocalAudioStateChanged');
  });
  test('onRemoteAudioStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioStateChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onActiveSpeaker impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onActiveSpeaker(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onContentInspectResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onContentInspectResult(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onContentInspectResult');
  });
  test('onSnapshotTaken impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onSnapshotTaken(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onClientRoleChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onClientRoleChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onClientRoleChangeFailed impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onClientRoleChangeFailed(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioDeviceVolumeChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioDeviceVolumeChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRtmpStreamingStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtmpStreamingStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRtmpStreamingEvent impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtmpStreamingEvent(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onTranscodingUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onTranscodingUpdated();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioRoutingChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioRoutingChanged(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onChannelMediaRelayStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onChannelMediaRelayStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith(
      'onChannelMediaRelayStateChanged'
    );
  });
  test('onChannelMediaRelayEvent impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onChannelMediaRelayEvent(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onChannelMediaRelayEvent');
  });
  test('onLocalPublishFallbackToAudioOnly impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalPublishFallbackToAudioOnly(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteSubscribeFallbackToAudioOnly impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onRemoteSubscribeFallbackToAudioOnly(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith(
      'onRemoteSubscribeFallbackToAudioOnly'
    );
  });
  test('onRemoteAudioTransportStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioTransportStats(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteVideoTransportStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoTransportStats(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onConnectionStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onWlAccMessage impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccMessage(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onWlAccStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccStats(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onNetworkTypeChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onNetworkTypeChanged(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onEncryptionError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onEncryptionError(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onPermissionError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onPermissionError(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLocalUserRegistered impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalUserRegistered(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserInfoUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserInfoUpdated(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUploadLogResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUploadLogResult(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioSubscribeStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioSubscribeStateChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onVideoSubscribeStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoSubscribeStateChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioPublishStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioPublishStateChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onVideoPublishStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoPublishStateChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onExtensionEvent impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionEvent(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onExtensionStarted impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionStarted(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onExtensionStopped impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionStopped(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onExtensionError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionError(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserAccountUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserAccountUpdated(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onLocalVideoTranscoderError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalVideoTranscoderError(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onVideoRenderingTracingResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoRenderingTracingResult(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
describe('IVideoDeviceManager', () => {
  test('enumerateVideoDevices impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'enumerateVideoDevices'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_enumerateVideoDevices',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .enumerateVideoDevices
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .enumerateVideoDevices
    ).toBeCalledWith();
  });

  test('setDevice parameter', async () => {
    let nParam = {
      deviceIdUTF8: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'VideoDeviceManager_setDevice',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setDevice impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'setDevice'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceIdUTF8: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_setDevice',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.setDevice
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.setDevice
    ).toBeCalledWith('test');
  });

  test('getDevice impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'getDevice'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_getDevice',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.getDevice
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.getDevice
    ).toBeCalledWith();
  });

  test('numberOfCapabilities impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'numberOfCapabilities'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceIdUTF8: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_numberOfCapabilities',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .numberOfCapabilities
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getCapability impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'getCapability'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceIdUTF8: 'test',
      deviceCapabilityNumber: 'test',
      capability: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_getCapability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .getCapability
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startDeviceTest impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'startDeviceTest'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      hwnd: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_startDeviceTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .startDeviceTest
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopDeviceTest impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'stopDeviceTest'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_stopDeviceTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .stopDeviceTest
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('release impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'release'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_release',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.release
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.release
    ).toBeCalledWith();
  });
});
describe('IMetadataObserver', () => {
  test('onMetadataReceived impl call', async () => {
    let eventHandler = new bindingAPI.IMetadataObserver(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onMetadataReceived(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
describe('IDirectCdnStreamingEventHandler', () => {
  test('onDirectCdnStreamingStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IDirectCdnStreamingEventHandler(
      irisRtcEngine
    );
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onDirectCdnStreamingStateChanged(
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onDirectCdnStreamingStats impl call', async () => {
    let eventHandler = new bindingAPI.IDirectCdnStreamingEventHandler(
      irisRtcEngine
    );
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onDirectCdnStreamingStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
describe('IRtcEngine', () => {
  test('release parameter', async () => {
    let nParam = {
      sync: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_release',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('release impl call', async () => {
    jest
      .spyOn(irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl, 'release')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sync: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_release',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.release
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.release
    ).toBeCalledWith('test');
  });

  test('initialize parameter', async () => {
    let nParam = {
      context: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_initialize',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('initialize impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'initialize'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      context: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_initialize',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.initialize
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.initialize
    ).toBeCalledWith('test');
  });

  test('getVersion impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getVersion'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getVersion',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getVersion
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getErrorDescription impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getErrorDescription'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      code: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getErrorDescription',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getErrorDescription
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('queryCodecCapability impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'queryCodecCapability'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      codecInfo: 'test',
      size: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_queryCodecCapability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .queryCodecCapability
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('preloadChannel impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'preloadChannel'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      uid: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_preloadChannel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.preloadChannel
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('preloadChannel2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'preloadChannel2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_preloadChannel2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.preloadChannel2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updatePreloadChannelToken impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updatePreloadChannelToken'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updatePreloadChannelToken',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updatePreloadChannelToken
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('joinChannel parameter', async () => {
    let nParam = {
      token: undefined,
      channelId: undefined,
      info: undefined,
      uid: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_joinChannel',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('joinChannel impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannel'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      info: 'test',
      uid: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('joinChannel2 parameter', async () => {
    let nParam = {
      token: undefined,
      channelId: undefined,
      uid: undefined,
      options: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_joinChannel2',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('joinChannel2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannel2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      uid: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannel2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel2
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('updateChannelMediaOptions parameter', async () => {
    let nParam = {
      options: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_updateChannelMediaOptions',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('updateChannelMediaOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateChannelMediaOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateChannelMediaOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateChannelMediaOptions
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateChannelMediaOptions
    ).toBeCalledWith('test');
  });

  test('leaveChannel impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'leaveChannel'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_leaveChannel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel
    ).toBeCalledWith();
  });

  test('leaveChannel2 parameter', async () => {
    let nParam = {
      options: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_leaveChannel2',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('leaveChannel2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'leaveChannel2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_leaveChannel2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel2
    ).toBeCalledWith('test');
  });

  test('renewToken impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'renewToken'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_renewToken',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.renewToken
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setChannelProfile parameter', async () => {
    let nParam = {
      profile: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setChannelProfile',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setChannelProfile impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setChannelProfile'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setChannelProfile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setChannelProfile
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setChannelProfile
    ).toBeCalledWith('test');
  });

  test('setClientRole parameter', async () => {
    let nParam = {
      role: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setClientRole',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setClientRole impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setClientRole'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      role: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setClientRole',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole
    ).toBeCalledWith('test');
  });

  test('setClientRole2 parameter', async () => {
    let nParam = {
      role: undefined,
      options: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setClientRole2',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setClientRole2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setClientRole2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      role: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setClientRole2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole2
    ).toBeCalledWith('test', 'test');
  });

  test('startEchoTest impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startEchoTest'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startEchoTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startEchoTest
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startEchoTest2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startEchoTest2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      intervalInSeconds: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startEchoTest2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startEchoTest2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startEchoTest3 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startEchoTest3'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startEchoTest3',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startEchoTest3
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopEchoTest impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopEchoTest'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopEchoTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopEchoTest
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableMultiCamera impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableMultiCamera'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableMultiCamera',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableMultiCamera
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableVideo
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableVideo
    ).toBeCalledWith();
  });

  test('disableVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'disableVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_disableVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableVideo
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableVideo
    ).toBeCalledWith();
  });

  test('startPreview impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startPreview'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startPreview',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview
    ).toBeCalledWith();
  });

  test('startPreview2 parameter', async () => {
    let nParam = {
      sourceType: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_startPreview2',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('startPreview2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startPreview2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startPreview2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview2
    ).toBeCalledWith('test');
  });

  test('stopPreview impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopPreview'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopPreview',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview
    ).toBeCalledWith();
  });

  test('stopPreview2 parameter', async () => {
    let nParam = {
      sourceType: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_stopPreview2',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('stopPreview2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopPreview2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopPreview2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview2
    ).toBeCalledWith('test');
  });

  test('startLastmileProbeTest impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startLastmileProbeTest'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startLastmileProbeTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startLastmileProbeTest
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopLastmileProbeTest impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopLastmileProbeTest'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopLastmileProbeTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .stopLastmileProbeTest
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setVideoEncoderConfiguration parameter', async () => {
    let nParam = {
      config: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setVideoEncoderConfiguration',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setVideoEncoderConfiguration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVideoEncoderConfiguration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVideoEncoderConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVideoEncoderConfiguration
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVideoEncoderConfiguration
    ).toBeCalledWith('test');
  });

  test('setBeautyEffectOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setBeautyEffectOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setBeautyEffectOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setBeautyEffectOptions
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLowlightEnhanceOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLowlightEnhanceOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLowlightEnhanceOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setLowlightEnhanceOptions
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setVideoDenoiserOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVideoDenoiserOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVideoDenoiserOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVideoDenoiserOptions
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setColorEnhanceOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setColorEnhanceOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setColorEnhanceOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setColorEnhanceOptions
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableVirtualBackground impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableVirtualBackground'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      backgroundSource: 'test',
      segproperty: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableVirtualBackground',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableVirtualBackground
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setupRemoteVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setupRemoteVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      canvas: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setupRemoteVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setupRemoteVideo
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setupLocalVideo parameter', async () => {
    let nParam = {
      canvas: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setupLocalVideo',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setupLocalVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setupLocalVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      canvas: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setupLocalVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setupLocalVideo
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setupLocalVideo
    ).toBeCalledWith('test');
  });

  test('setVideoScenario impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVideoScenario'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      scenarioType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVideoScenario',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setVideoScenario
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableAudio
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableAudio
    ).toBeCalledWith();
  });

  test('disableAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'disableAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_disableAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableAudio
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableAudio
    ).toBeCalledWith();
  });

  test('setAudioProfile parameter', async () => {
    let nParam = {
      profile: undefined,
      scenario: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setAudioProfile',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setAudioProfile impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioProfile'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
      scenario: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioProfile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile
    ).toBeCalledWith('test', 'test');
  });

  test('setAudioProfile2 parameter', async () => {
    let nParam = {
      profile: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setAudioProfile2',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setAudioProfile2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioProfile2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioProfile2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile2
    ).toBeCalledWith('test');
  });

  test('setAudioScenario impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioScenario'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      scenario: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioScenario',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioScenario
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableLocalAudio parameter', async () => {
    let nParam = {
      enabled: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_enableLocalAudio',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('enableLocalAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableLocalAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableLocalAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableLocalAudio
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableLocalAudio
    ).toBeCalledWith('test');
  });

  test('muteLocalAudioStream parameter', async () => {
    let nParam = {
      mute: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_muteLocalAudioStream',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('muteLocalAudioStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteLocalAudioStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteLocalAudioStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteLocalAudioStream
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteLocalAudioStream
    ).toBeCalledWith('test');
  });

  test('muteAllRemoteAudioStreams parameter', async () => {
    let nParam = {
      mute: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_muteAllRemoteAudioStreams',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('muteAllRemoteAudioStreams impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteAllRemoteAudioStreams'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteAllRemoteAudioStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteAllRemoteAudioStreams
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteAllRemoteAudioStreams
    ).toBeCalledWith('test');
  });

  test('setDefaultMuteAllRemoteAudioStreams impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setDefaultMuteAllRemoteAudioStreams'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDefaultMuteAllRemoteAudioStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setDefaultMuteAllRemoteAudioStreams
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteRemoteAudioStream parameter', async () => {
    let nParam = {
      uid: undefined,
      mute: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_muteRemoteAudioStream',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('muteRemoteAudioStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteRemoteAudioStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteRemoteAudioStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteRemoteAudioStream
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteRemoteAudioStream
    ).toBeCalledWith('test', 'test');
  });

  test('muteLocalVideoStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteLocalVideoStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteLocalVideoStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteLocalVideoStream
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableLocalVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableLocalVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableLocalVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableLocalVideo
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteAllRemoteVideoStreams impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteAllRemoteVideoStreams'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteAllRemoteVideoStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteAllRemoteVideoStreams
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setDefaultMuteAllRemoteVideoStreams impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setDefaultMuteAllRemoteVideoStreams'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDefaultMuteAllRemoteVideoStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setDefaultMuteAllRemoteVideoStreams
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteRemoteVideoStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteRemoteVideoStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteRemoteVideoStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteRemoteVideoStream
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteVideoStreamType impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteVideoStreamType'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      streamType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteVideoStreamType',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRemoteVideoStreamType
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteVideoSubscriptionOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteVideoSubscriptionOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteVideoSubscriptionOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRemoteVideoSubscriptionOptions
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteDefaultVideoStreamType impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteDefaultVideoStreamType'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteDefaultVideoStreamType',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRemoteDefaultVideoStreamType
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeAudioBlocklist impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setSubscribeAudioBlocklist'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeAudioBlocklist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setSubscribeAudioBlocklist
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeAudioAllowlist impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setSubscribeAudioAllowlist'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeAudioAllowlist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setSubscribeAudioAllowlist
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeVideoBlocklist impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setSubscribeVideoBlocklist'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeVideoBlocklist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setSubscribeVideoBlocklist
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeVideoAllowlist impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setSubscribeVideoAllowlist'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeVideoAllowlist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setSubscribeVideoAllowlist
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableAudioVolumeIndication parameter', async () => {
    let nParam = {
      interval: undefined,
      smooth: undefined,
      reportVad: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_enableAudioVolumeIndication',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('enableAudioVolumeIndication impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableAudioVolumeIndication'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      interval: 'test',
      smooth: 'test',
      reportVad: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableAudioVolumeIndication',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableAudioVolumeIndication
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableAudioVolumeIndication
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('startAudioRecording impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startAudioRecording'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      quality: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioRecording',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startAudioRecording
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startAudioRecording2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startAudioRecording2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      sampleRate: 'test',
      quality: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioRecording2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startAudioRecording2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startAudioRecording3 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startAudioRecording3'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioRecording3',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startAudioRecording3
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerAudioEncodedFrameObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'registerAudioEncodedFrameObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerAudioEncodedFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerAudioEncodedFrameObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopAudioRecording impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopAudioRecording'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAudioRecording',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopAudioRecording
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createMediaPlayer impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'createMediaPlayer'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createMediaPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.createMediaPlayer
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('destroyMediaPlayer impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'destroyMediaPlayer'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      media_player: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyMediaPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.destroyMediaPlayer
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createMediaRecorder impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'createMediaRecorder'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      info: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createMediaRecorder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.createMediaRecorder
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('destroyMediaRecorder impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'destroyMediaRecorder'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mediaRecorder: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyMediaRecorder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .destroyMediaRecorder
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startAudioMixing impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startAudioMixing'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      loopback: 'test',
      cycle: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startAudioMixing
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startAudioMixing2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startAudioMixing2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      loopback: 'test',
      cycle: 'test',
      startPos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioMixing2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startAudioMixing2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopAudioMixing impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopAudioMixing'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopAudioMixing
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pauseAudioMixing impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'pauseAudioMixing'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.pauseAudioMixing
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('resumeAudioMixing impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'resumeAudioMixing'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.resumeAudioMixing
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('selectAudioTrack impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'selectAudioTrack'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      index: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_selectAudioTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.selectAudioTrack
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getAudioTrackCount impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getAudioTrackCount'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioTrackCount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getAudioTrackCount
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustAudioMixingVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustAudioMixingVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustAudioMixingVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustAudioMixingVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustAudioMixingPublishVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustAudioMixingPublishVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustAudioMixingPublishVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustAudioMixingPublishVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getAudioMixingPublishVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getAudioMixingPublishVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingPublishVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getAudioMixingPublishVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustAudioMixingPlayoutVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustAudioMixingPlayoutVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustAudioMixingPlayoutVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustAudioMixingPlayoutVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getAudioMixingPlayoutVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getAudioMixingPlayoutVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingPlayoutVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getAudioMixingPlayoutVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getAudioMixingDuration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getAudioMixingDuration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingDuration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getAudioMixingDuration
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getAudioMixingCurrentPosition impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getAudioMixingCurrentPosition'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingCurrentPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getAudioMixingCurrentPosition
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAudioMixingPosition impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioMixingPosition'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      pos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioMixingPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setAudioMixingPosition
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAudioMixingDualMonoMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioMixingDualMonoMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioMixingDualMonoMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setAudioMixingDualMonoMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAudioMixingPitch impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioMixingPitch'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      pitch: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioMixingPitch',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioMixingPitch
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getEffectsVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getEffectsVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getEffectsVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getEffectsVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setEffectsVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setEffectsVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEffectsVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setEffectsVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('preloadEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'preloadEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      filePath: 'test',
      startPos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_preloadEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.preloadEffect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('playEffect parameter', async () => {
    let nParam = {
      soundId: undefined,
      filePath: undefined,
      loopCount: undefined,
      pitch: undefined,
      pan: undefined,
      gain: undefined,
      publish: undefined,
      startPos: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_playEffect',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('playEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'playEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      filePath: 'test',
      loopCount: 'test',
      pitch: 'test',
      pan: 'test',
      gain: 'test',
      publish: 'test',
      startPos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_playEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.playEffect
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.playEffect
    ).toBeCalledWith(
      'test',
      'test',
      'test',
      'test',
      'test',
      'test',
      'test',
      'test'
    );
  });

  test('playAllEffects impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'playAllEffects'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      loopCount: 'test',
      pitch: 'test',
      pan: 'test',
      gain: 'test',
      publish: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_playAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.playAllEffects
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getVolumeOfEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getVolumeOfEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getVolumeOfEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getVolumeOfEffect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setVolumeOfEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVolumeOfEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVolumeOfEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setVolumeOfEffect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pauseEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'pauseEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.pauseEffect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pauseAllEffects impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'pauseAllEffects'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.pauseAllEffects
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('resumeEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'resumeEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.resumeEffect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('resumeAllEffects impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'resumeAllEffects'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.resumeAllEffects
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopEffect parameter', async () => {
    let nParam = {
      soundId: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_stopEffect',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('stopEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopEffect
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopEffect
    ).toBeCalledWith('test');
  });

  test('stopAllEffects impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopAllEffects'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopAllEffects
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopAllEffects
    ).toBeCalledWith();
  });

  test('unloadEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'unloadEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unloadEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.unloadEffect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('unloadAllEffects impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'unloadAllEffects'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unloadAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.unloadAllEffects
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getEffectDuration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getEffectDuration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getEffectDuration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getEffectDuration
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setEffectPosition impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setEffectPosition'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      pos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEffectPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setEffectPosition
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getEffectCurrentPosition impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getEffectCurrentPosition'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getEffectCurrentPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getEffectCurrentPosition
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableSoundPositionIndication impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableSoundPositionIndication'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableSoundPositionIndication',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableSoundPositionIndication
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteVoicePosition impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteVoicePosition'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      pan: 'test',
      gain: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteVoicePosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRemoteVoicePosition
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableSpatialAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableSpatialAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableSpatialAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableSpatialAudio
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteUserSpatialAudioParams impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteUserSpatialAudioParams'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      params: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteUserSpatialAudioParams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRemoteUserSpatialAudioParams
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setVoiceBeautifierPreset impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVoiceBeautifierPreset'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceBeautifierPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVoiceBeautifierPreset
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAudioEffectPreset impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioEffectPreset'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioEffectPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setAudioEffectPreset
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setVoiceConversionPreset impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVoiceConversionPreset'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceConversionPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVoiceConversionPreset
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAudioEffectParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioEffectParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
      param1: 'test',
      param2: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioEffectParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setAudioEffectParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setVoiceBeautifierParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVoiceBeautifierParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
      param1: 'test',
      param2: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceBeautifierParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVoiceBeautifierParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setVoiceConversionParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVoiceConversionParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
      param1: 'test',
      param2: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceConversionParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVoiceConversionParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalVoicePitch impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalVoicePitch'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      pitch: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoicePitch',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalVoicePitch
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalVoiceFormant impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalVoiceFormant'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      formantRatio: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoiceFormant',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setLocalVoiceFormant
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalVoiceEqualization impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalVoiceEqualization'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      bandFrequency: 'test',
      bandGain: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoiceEqualization',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setLocalVoiceEqualization
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalVoiceReverb impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalVoiceReverb'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      reverbKey: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoiceReverb',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalVoiceReverb
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setHeadphoneEQPreset impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setHeadphoneEQPreset'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setHeadphoneEQPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setHeadphoneEQPreset
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setHeadphoneEQParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setHeadphoneEQParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      lowGain: 'test',
      highGain: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setHeadphoneEQParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setHeadphoneEQParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLogFile impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLogFile'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogFile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLogFile
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLogFilter impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLogFilter'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filter: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogFilter',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLogFilter
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLogLevel parameter', async () => {
    let nParam = {
      level: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setLogLevel',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setLogLevel impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLogLevel'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      level: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogLevel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLogLevel
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLogLevel
    ).toBeCalledWith('test');
  });

  test('setLogFileSize impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLogFileSize'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      fileSizeInKBytes: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogFileSize',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLogFileSize
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('uploadLogFile impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'uploadLogFile'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      requestId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_uploadLogFile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.uploadLogFile
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalRenderMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalRenderMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      renderMode: 'test',
      mirrorMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalRenderMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalRenderMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteRenderMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteRenderMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      renderMode: 'test',
      mirrorMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteRenderMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setRemoteRenderMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalRenderMode2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalRenderMode2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      renderMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalRenderMode2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalRenderMode2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalVideoMirrorMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalVideoMirrorMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mirrorMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVideoMirrorMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setLocalVideoMirrorMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableDualStreamMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableDualStreamMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableDualStreamMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableDualStreamMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableDualStreamMode2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableDualStreamMode2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      streamConfig: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableDualStreamMode2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableDualStreamMode2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setDualStreamMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setDualStreamMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDualStreamMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setDualStreamMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setDualStreamMode2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setDualStreamMode2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
      streamConfig: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDualStreamMode2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setDualStreamMode2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableCustomAudioLocalPlayback impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableCustomAudioLocalPlayback'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableCustomAudioLocalPlayback',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableCustomAudioLocalPlayback
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRecordingAudioFrameParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRecordingAudioFrameParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      mode: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRecordingAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRecordingAudioFrameParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setPlaybackAudioFrameParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setPlaybackAudioFrameParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      mode: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setPlaybackAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setPlaybackAudioFrameParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setMixedAudioFrameParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setMixedAudioFrameParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setMixedAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setMixedAudioFrameParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setEarMonitoringAudioFrameParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setEarMonitoringAudioFrameParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      mode: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEarMonitoringAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setEarMonitoringAudioFrameParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setPlaybackAudioFrameBeforeMixingParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setPlaybackAudioFrameBeforeMixingParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setPlaybackAudioFrameBeforeMixingParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setPlaybackAudioFrameBeforeMixingParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableAudioSpectrumMonitor impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableAudioSpectrumMonitor'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      intervalInMS: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableAudioSpectrumMonitor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableAudioSpectrumMonitor
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('disableAudioSpectrumMonitor impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'disableAudioSpectrumMonitor'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_disableAudioSpectrumMonitor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .disableAudioSpectrumMonitor
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerAudioSpectrumObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'registerAudioSpectrumObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerAudioSpectrumObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerAudioSpectrumObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('unregisterAudioSpectrumObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'unregisterAudioSpectrumObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unregisterAudioSpectrumObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .unregisterAudioSpectrumObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustRecordingSignalVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustRecordingSignalVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustRecordingSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustRecordingSignalVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteRecordingSignal impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteRecordingSignal'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteRecordingSignal',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.muteRecordingSignal
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustPlaybackSignalVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustPlaybackSignalVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustPlaybackSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustPlaybackSignalVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustUserPlaybackSignalVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustUserPlaybackSignalVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustUserPlaybackSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustUserPlaybackSignalVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalPublishFallbackOption impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalPublishFallbackOption'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalPublishFallbackOption',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setLocalPublishFallbackOption
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteSubscribeFallbackOption impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteSubscribeFallbackOption'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteSubscribeFallbackOption',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRemoteSubscribeFallbackOption
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setHighPriorityUserList impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setHighPriorityUserList'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNum: 'test',
      option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setHighPriorityUserList',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setHighPriorityUserList
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableLoopbackRecording impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableLoopbackRecording'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      deviceName: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableLoopbackRecording',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableLoopbackRecording
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustLoopbackSignalVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustLoopbackSignalVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustLoopbackSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustLoopbackSignalVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getLoopbackRecordingVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getLoopbackRecordingVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getLoopbackRecordingVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getLoopbackRecordingVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableInEarMonitoring impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableInEarMonitoring'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      includeAudioFilters: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableInEarMonitoring',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableInEarMonitoring
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setInEarMonitoringVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setInEarMonitoringVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setInEarMonitoringVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setInEarMonitoringVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('loadExtensionProvider impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'loadExtensionProvider'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      path: 'test',
      unload_after_use: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_loadExtensionProvider',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .loadExtensionProvider
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setExtensionProviderProperty impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setExtensionProviderProperty'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      key: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setExtensionProviderProperty',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setExtensionProviderProperty
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerExtension impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'registerExtension'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerExtension',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.registerExtension
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableExtension impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableExtension'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      enable: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableExtension',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableExtension
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableExtension2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableExtension2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      extensionInfo: 'test',
      enable: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableExtension2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableExtension2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setExtensionProperty impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setExtensionProperty'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      key: 'test',
      value: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setExtensionProperty',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setExtensionProperty
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getExtensionProperty impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getExtensionProperty'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      key: 'test',
      value: 'test',
      buf_len: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getExtensionProperty',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getExtensionProperty
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setExtensionProperty2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setExtensionProperty2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      extensionInfo: 'test',
      key: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setExtensionProperty2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setExtensionProperty2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getExtensionProperty2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getExtensionProperty2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      extensionInfo: 'test',
      key: 'test',
      value: 'test',
      buf_len: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getExtensionProperty2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getExtensionProperty2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraCapturerConfiguration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraCapturerConfiguration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraCapturerConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setCameraCapturerConfiguration
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createCustomVideoTrack impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'createCustomVideoTrack'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createCustomVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .createCustomVideoTrack
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createCustomEncodedVideoTrack impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'createCustomEncodedVideoTrack'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sender_option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createCustomEncodedVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .createCustomEncodedVideoTrack
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('destroyCustomVideoTrack impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'destroyCustomVideoTrack'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      video_track_id: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyCustomVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .destroyCustomVideoTrack
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('destroyCustomEncodedVideoTrack impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'destroyCustomEncodedVideoTrack'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      video_track_id: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyCustomEncodedVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .destroyCustomEncodedVideoTrack
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('switchCamera impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'switchCamera'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_switchCamera',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.switchCamera
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraZoomSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraZoomSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraZoomSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraZoomSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraFaceDetectSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraFaceDetectSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraFaceDetectSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraFaceDetectSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraTorchSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraTorchSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraTorchSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraTorchSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraFocusSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraFocusSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraFocusSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraFocusSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraAutoFocusFaceModeSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraAutoFocusFaceModeSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraAutoFocusFaceModeSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraAutoFocusFaceModeSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraZoomFactor impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraZoomFactor'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      factor: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraZoomFactor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setCameraZoomFactor
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableFaceDetection impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableFaceDetection'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableFaceDetection',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableFaceDetection
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getCameraMaxZoomFactor impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getCameraMaxZoomFactor'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getCameraMaxZoomFactor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getCameraMaxZoomFactor
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraFocusPositionInPreview impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraFocusPositionInPreview'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      positionX: 'test',
      positionY: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraFocusPositionInPreview',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setCameraFocusPositionInPreview
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraTorchOn impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraTorchOn'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      isOn: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraTorchOn',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setCameraTorchOn
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraAutoFocusFaceModeEnabled impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraAutoFocusFaceModeEnabled'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraAutoFocusFaceModeEnabled',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setCameraAutoFocusFaceModeEnabled
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraExposurePositionSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraExposurePositionSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraExposurePositionSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraExposurePositionSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraExposurePosition impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraExposurePosition'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      positionXinView: 'test',
      positionYinView: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraExposurePosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setCameraExposurePosition
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraExposureSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraExposureSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraExposureSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraExposureSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraExposureFactor impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraExposureFactor'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      factor: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraExposureFactor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setCameraExposureFactor
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isCameraAutoExposureFaceModeSupported impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isCameraAutoExposureFaceModeSupported'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraAutoExposureFaceModeSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isCameraAutoExposureFaceModeSupported
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraAutoExposureFaceModeEnabled impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraAutoExposureFaceModeEnabled'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraAutoExposureFaceModeEnabled',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setCameraAutoExposureFaceModeEnabled
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setDefaultAudioRouteToSpeakerphone impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setDefaultAudioRouteToSpeakerphone'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      defaultToSpeaker: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDefaultAudioRouteToSpeakerphone',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setDefaultAudioRouteToSpeakerphone
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setEnableSpeakerphone impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setEnableSpeakerphone'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      speakerOn: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEnableSpeakerphone',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setEnableSpeakerphone
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isSpeakerphoneEnabled impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isSpeakerphoneEnabled'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isSpeakerphoneEnabled',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isSpeakerphoneEnabled
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRouteInCommunicationMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRouteInCommunicationMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      route: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRouteInCommunicationMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRouteInCommunicationMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getScreenCaptureSources impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getScreenCaptureSources'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      thumbSize: 'test',
      iconSize: 'test',
      includeScreen: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getScreenCaptureSources',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getScreenCaptureSources
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAudioSessionOperationRestriction impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioSessionOperationRestriction'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      restriction: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioSessionOperationRestriction',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setAudioSessionOperationRestriction
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startScreenCaptureByDisplayId impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startScreenCaptureByDisplayId'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      displayId: 'test',
      regionRect: 'test',
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCaptureByDisplayId',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startScreenCaptureByDisplayId
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startScreenCaptureByScreenRect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startScreenCaptureByScreenRect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      screenRect: 'test',
      regionRect: 'test',
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCaptureByScreenRect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startScreenCaptureByScreenRect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getAudioDeviceInfo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getAudioDeviceInfo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceInfo: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioDeviceInfo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getAudioDeviceInfo
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startScreenCaptureByWindowId impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startScreenCaptureByWindowId'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      windowId: 'test',
      regionRect: 'test',
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCaptureByWindowId',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startScreenCaptureByWindowId
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setScreenCaptureContentHint impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setScreenCaptureContentHint'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      contentHint: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setScreenCaptureContentHint',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setScreenCaptureContentHint
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateScreenCaptureRegion impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateScreenCaptureRegion'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      regionRect: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateScreenCaptureRegion',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateScreenCaptureRegion
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateScreenCaptureParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateScreenCaptureParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateScreenCaptureParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateScreenCaptureParameters
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startScreenCapture parameter', async () => {
    let nParam = {
      captureParams: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_startScreenCapture',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('startScreenCapture impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startScreenCapture'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startScreenCapture
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startScreenCapture
    ).toBeCalledWith('test');
  });

  test('updateScreenCapture impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateScreenCapture'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateScreenCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.updateScreenCapture
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('queryScreenCaptureCapability impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'queryScreenCaptureCapability'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_queryScreenCaptureCapability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .queryScreenCaptureCapability
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setScreenCaptureScenario impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setScreenCaptureScenario'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      screenScenario: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setScreenCaptureScenario',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setScreenCaptureScenario
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopScreenCapture impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopScreenCapture'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopScreenCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture
    ).toBeCalledWith();
  });

  test('getCallId impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getCallId'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      callId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getCallId',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getCallId
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('rate impl call', async () => {
    jest
      .spyOn(irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl, 'rate')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      callId: 'test',
      rating: 'test',
      description: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_rate',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.rate
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('complain impl call', async () => {
    jest
      .spyOn(irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl, 'complain')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      callId: 'test',
      description: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_complain',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.complain
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startRtmpStreamWithoutTranscoding impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startRtmpStreamWithoutTranscoding'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startRtmpStreamWithoutTranscoding',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startRtmpStreamWithoutTranscoding
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startRtmpStreamWithTranscoding impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startRtmpStreamWithTranscoding'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      transcoding: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startRtmpStreamWithTranscoding',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startRtmpStreamWithTranscoding
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateRtmpTranscoding impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateRtmpTranscoding'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      transcoding: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateRtmpTranscoding',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateRtmpTranscoding
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopRtmpStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopRtmpStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopRtmpStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopRtmpStream
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startLocalVideoTranscoder impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startLocalVideoTranscoder'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startLocalVideoTranscoder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startLocalVideoTranscoder
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateLocalTranscoderConfiguration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateLocalTranscoderConfiguration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateLocalTranscoderConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateLocalTranscoderConfiguration
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopLocalVideoTranscoder impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopLocalVideoTranscoder'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopLocalVideoTranscoder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .stopLocalVideoTranscoder
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startCameraCapture impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startCameraCapture'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startCameraCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startCameraCapture
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopCameraCapture impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopCameraCapture'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopCameraCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopCameraCapture
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCameraDeviceOrientation impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCameraDeviceOrientation'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      type: 'test',
      orientation: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraDeviceOrientation',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setCameraDeviceOrientation
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setScreenCaptureOrientation impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setScreenCaptureOrientation'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      type: 'test',
      orientation: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setScreenCaptureOrientation',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setScreenCaptureOrientation
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startScreenCapture2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startScreenCapture2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCapture2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startScreenCapture2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopScreenCapture2 parameter', async () => {
    let nParam = {
      sourceType: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_stopScreenCapture2',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('stopScreenCapture2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopScreenCapture2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopScreenCapture2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture2
    ).toBeCalledWith('test');
  });

  test('getConnectionState impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getConnectionState'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getConnectionState',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getConnectionState
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerEventHandler parameter', async () => {
    let nParam = {
      eventHandler: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_registerEventHandler',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('registerEventHandler impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'registerEventHandler'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      eventHandler: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerEventHandler',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerEventHandler
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerEventHandler
    ).toBeCalledWith('test');
  });

  test('unregisterEventHandler parameter', async () => {
    let nParam = {
      eventHandler: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_unregisterEventHandler',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('unregisterEventHandler impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'unregisterEventHandler'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      eventHandler: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unregisterEventHandler',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .unregisterEventHandler
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .unregisterEventHandler
    ).toBeCalledWith('test');
  });

  test('setRemoteUserPriority impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteUserPriority'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      userPriority: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteUserPriority',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setRemoteUserPriority
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setEncryptionMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setEncryptionMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      encryptionMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEncryptionMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setEncryptionMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setEncryptionSecret impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setEncryptionSecret'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      secret: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEncryptionSecret',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setEncryptionSecret
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableEncryption impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableEncryption'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableEncryption',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableEncryption
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createDataStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'createDataStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      reliable: 'test',
      ordered: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createDataStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.createDataStream
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createDataStream2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'createDataStream2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createDataStream2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.createDataStream2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('sendStreamMessage impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'sendStreamMessage'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      data: 'test',
      length: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_sendStreamMessage',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.sendStreamMessage
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('addVideoWatermark impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'addVideoWatermark'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      watermark: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_addVideoWatermark',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.addVideoWatermark
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('addVideoWatermark2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'addVideoWatermark2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      watermarkUrl: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_addVideoWatermark2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.addVideoWatermark2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('clearVideoWatermarks impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'clearVideoWatermarks'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_clearVideoWatermarks',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .clearVideoWatermarks
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pauseAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'pauseAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.pauseAudio
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('resumeAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'resumeAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.resumeAudio
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableWebSdkInteroperability impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableWebSdkInteroperability'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableWebSdkInteroperability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableWebSdkInteroperability
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('sendCustomReportMessage impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'sendCustomReportMessage'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      id: 'test',
      category: 'test',
      event: 'test',
      label: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_sendCustomReportMessage',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .sendCustomReportMessage
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerMediaMetadataObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'registerMediaMetadataObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerMediaMetadataObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerMediaMetadataObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('unregisterMediaMetadataObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'unregisterMediaMetadataObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unregisterMediaMetadataObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .unregisterMediaMetadataObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startAudioFrameDump impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startAudioFrameDump'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      channel_id: 'test',
      user_id: 'test',
      location: 'test',
      uuid: 'test',
      passwd: 'test',
      duration_ms: 'test',
      auto_upload: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioFrameDump',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startAudioFrameDump
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopAudioFrameDump impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopAudioFrameDump'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      channel_id: 'test',
      user_id: 'test',
      location: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAudioFrameDump',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopAudioFrameDump
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAINSMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAINSMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      mode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAINSMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAINSMode
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerLocalUserAccount impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'registerLocalUserAccount'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      appId: 'test',
      userAccount: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerLocalUserAccount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerLocalUserAccount
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('joinChannelWithUserAccount impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannelWithUserAccount'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannelWithUserAccount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .joinChannelWithUserAccount
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('joinChannelWithUserAccount2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannelWithUserAccount2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannelWithUserAccount2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .joinChannelWithUserAccount2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('joinChannelWithUserAccountEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannelWithUserAccountEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannelWithUserAccountEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .joinChannelWithUserAccountEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getUserInfoByUserAccount impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getUserInfoByUserAccount'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      userAccount: 'test',
      userInfo: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getUserInfoByUserAccount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getUserInfoByUserAccount
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getUserInfoByUid impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getUserInfoByUid'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      userInfo: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getUserInfoByUid',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getUserInfoByUid
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startOrUpdateChannelMediaRelay impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startOrUpdateChannelMediaRelay'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startOrUpdateChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startOrUpdateChannelMediaRelay
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startChannelMediaRelay impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startChannelMediaRelay'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startChannelMediaRelay
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateChannelMediaRelay impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateChannelMediaRelay'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateChannelMediaRelay
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopChannelMediaRelay impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopChannelMediaRelay'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .stopChannelMediaRelay
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pauseAllChannelMediaRelay impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'pauseAllChannelMediaRelay'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAllChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .pauseAllChannelMediaRelay
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('resumeAllChannelMediaRelay impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'resumeAllChannelMediaRelay'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAllChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .resumeAllChannelMediaRelay
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setDirectCdnStreamingAudioConfiguration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setDirectCdnStreamingAudioConfiguration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDirectCdnStreamingAudioConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setDirectCdnStreamingAudioConfiguration
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setDirectCdnStreamingVideoConfiguration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setDirectCdnStreamingVideoConfiguration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDirectCdnStreamingVideoConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setDirectCdnStreamingVideoConfiguration
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startDirectCdnStreaming impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startDirectCdnStreaming'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      eventHandler: 'test',
      publishUrl: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startDirectCdnStreaming',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startDirectCdnStreaming
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopDirectCdnStreaming impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopDirectCdnStreaming'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopDirectCdnStreaming',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .stopDirectCdnStreaming
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateDirectCdnStreamingMediaOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateDirectCdnStreamingMediaOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateDirectCdnStreamingMediaOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateDirectCdnStreamingMediaOptions
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startRhythmPlayer impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startRhythmPlayer'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sound1: 'test',
      sound2: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startRhythmPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startRhythmPlayer
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopRhythmPlayer impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopRhythmPlayer'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopRhythmPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopRhythmPlayer
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('configRhythmPlayer impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'configRhythmPlayer'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_configRhythmPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.configRhythmPlayer
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('takeSnapshot impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'takeSnapshot'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_takeSnapshot',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.takeSnapshot
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableContentInspect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableContentInspect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableContentInspect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableContentInspect
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustCustomAudioPublishVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustCustomAudioPublishVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustCustomAudioPublishVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustCustomAudioPublishVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustCustomAudioPlayoutVolume impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'adjustCustomAudioPlayoutVolume'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustCustomAudioPlayoutVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .adjustCustomAudioPlayoutVolume
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setCloudProxy impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setCloudProxy'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      proxyType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCloudProxy',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setCloudProxy
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setLocalAccessPoint impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalAccessPoint'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalAccessPoint',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalAccessPoint
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAdvancedAudioOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAdvancedAudioOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAdvancedAudioOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setAdvancedAudioOptions
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setAVSyncSource impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAVSyncSource'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      channelId: 'test',
      uid: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAVSyncSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAVSyncSource
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableVideoImageSource impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableVideoImageSource'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enable: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableVideoImageSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableVideoImageSource
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getCurrentMonotonicTimeInMs impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getCurrentMonotonicTimeInMs'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getCurrentMonotonicTimeInMs',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getCurrentMonotonicTimeInMs
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableWirelessAccelerate impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableWirelessAccelerate'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableWirelessAccelerate',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableWirelessAccelerate
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getNetworkType impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getNetworkType'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getNetworkType',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getNetworkType
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setParameters parameter', async () => {
    let nParam = {
      parameters: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngine_setParameters',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      parameters: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setParameters
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setParameters
    ).toBeCalledWith('test');
  });

  test('startMediaRenderingTracing impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startMediaRenderingTracing'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startMediaRenderingTracing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .startMediaRenderingTracing
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableInstantMediaRendering impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableInstantMediaRendering'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableInstantMediaRendering',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableInstantMediaRendering
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getNtpWallTimeInMs impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getNtpWallTimeInMs'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getNtpWallTimeInMs',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getNtpWallTimeInMs
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('isFeatureAvailableOnDevice impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'isFeatureAvailableOnDevice'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isFeatureAvailableOnDevice',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .isFeatureAvailableOnDevice
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});

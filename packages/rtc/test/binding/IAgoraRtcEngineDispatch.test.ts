/// Generated by terra, DO NOT MODIFY BY HAND.

import * as NATIVE_RTC from '@iris/native-rtc';
import { CallIrisApiResult, IrisApiEngine, IrisCore } from 'iris-web-core';

import { IrisWebRtc } from '../../src/IrisRtcApi';
import * as bufferExtensions from '../../src/extensions/CallApiBufferExtensions';
import { IrisRtcEngine } from '../engine/IrisRtcEngine';

const bindingAPI = require('../../src/binding/IAgoraRtcEngineDispatch');

let apiEnginePtr: IrisApiEngine;
let irisRtcEngine: IrisRtcEngine;
beforeAll(async () => {
  apiEnginePtr = IrisCore.createIrisApiEngine();
  IrisWebRtc.initIrisRtc(apiEnginePtr);
  irisRtcEngine = apiEnginePtr['apiInterceptors'][0];
  irisRtcEngine.implHelper.createMicrophoneAudioTrack = jest.fn();
  let nParam = {
    context: 'test',
  };
  let apiParam = new IrisCore.EventParam(
    'RtcEngine_initialize',
    JSON.stringify(nParam),
    0,
    '',
    ['test'],
    [],
    1
  );
  await IrisCore.callIrisApi(apiEnginePtr, apiParam);
});

afterAll(() => {
  IrisCore.disposeIrisApiEngine(apiEnginePtr);
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('IRtcEngineEventHandler', () => {
  test('RtcEngineEventHandler_onJoinChannelSuccess impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onJoinChannelSuccess(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRejoinChannelSuccess impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRejoinChannelSuccess(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onProxyConnected impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onProxyConnected(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onError(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onAudioQuality impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioQuality(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLastmileProbeResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLastmileProbeResult(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioVolumeIndication impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioVolumeIndication(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLeaveChannel impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLeaveChannel(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRtcStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtcStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioDeviceStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onAudioDeviceStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onAudioMixingPositionChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioMixingPositionChanged(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioMixingFinished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioMixingFinished();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioEffectFinished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onAudioEffectFinished(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onVideoDeviceStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onVideoDeviceStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onNetworkQuality impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onNetworkQuality(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onIntraRequestReceived impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onIntraRequestReceived();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUplinkNetworkInfoUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUplinkNetworkInfoUpdated(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onDownlinkNetworkInfoUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onDownlinkNetworkInfoUpdated(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLastmileQuality impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLastmileQuality(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstLocalVideoFrame impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onFirstLocalVideoFrame(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onFirstLocalVideoFramePublished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstLocalVideoFramePublished(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstRemoteVideoDecoded impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteVideoDecoded(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onVideoSizeChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoSizeChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalVideoStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onLocalVideoStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onRemoteVideoStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoStateChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstRemoteVideoFrame impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteVideoFrame(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserJoined impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserJoined(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserOffline impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserOffline(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserMuteAudio impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserMuteAudio(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserMuteVideo impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserMuteVideo(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserEnableVideo impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserEnableVideo(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onUserStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUserEnableLocalVideo impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onUserEnableLocalVideo(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onLocalAudioStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalAudioStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteAudioStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalVideoStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalVideoStats(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteVideoStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onCameraReady impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onCameraReady();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onCameraFocusAreaChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onCameraFocusAreaChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onCameraExposureAreaChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onCameraExposureAreaChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFacePositionChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFacePositionChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onVideoStopped impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoStopped();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioMixingStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioMixingStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRhythmPlayerStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRhythmPlayerStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onConnectionLost impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionLost();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onConnectionInterrupted impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionInterrupted();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onConnectionBanned impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionBanned();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onStreamMessage impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onStreamMessage(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onStreamMessageError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onStreamMessageError(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRequestToken impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRequestToken();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onTokenPrivilegeWillExpire impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onTokenPrivilegeWillExpire(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLicenseValidationFailure impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLicenseValidationFailure(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstLocalAudioFramePublished impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstLocalAudioFramePublished(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstRemoteAudioFrame impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteAudioFrame(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstRemoteAudioDecoded impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstRemoteAudioDecoded(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalAudioStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onLocalAudioStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onRemoteAudioStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioStateChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onActiveSpeaker impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onActiveSpeaker(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onContentInspectResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onContentInspectResult(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onSnapshotTaken impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onSnapshotTaken(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onClientRoleChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onClientRoleChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onClientRoleChangeFailed impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onClientRoleChangeFailed(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioDeviceVolumeChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioDeviceVolumeChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRtmpStreamingStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtmpStreamingStateChanged(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRtmpStreamingEvent impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtmpStreamingEvent(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onTranscodingUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onTranscodingUpdated();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioRoutingChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioRoutingChanged(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onChannelMediaRelayStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onChannelMediaRelayStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onChannelMediaRelayEvent impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onChannelMediaRelayEvent(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalPublishFallbackToAudioOnly impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalPublishFallbackToAudioOnly(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteSubscribeFallbackToAudioOnly impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onRemoteSubscribeFallbackToAudioOnly(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onRemoteAudioTransportStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioTransportStats(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteVideoTransportStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoTransportStats(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onConnectionStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onConnectionStateChanged(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onWlAccMessage impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccMessage(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onWlAccStats impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccStats(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onNetworkTypeChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onNetworkTypeChanged(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onEncryptionError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onEncryptionError(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onPermissionError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onPermissionError(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalUserRegistered impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalUserRegistered(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserInfoUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onUserInfoUpdated(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUploadLogResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUploadLogResult(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioSubscribeStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioSubscribeStateChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onVideoSubscribeStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoSubscribeStateChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioPublishStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioPublishStateChanged(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onVideoPublishStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoPublishStateChanged(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onExtensionEvent impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionEvent(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onExtensionStarted impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionStarted(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onExtensionStopped impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionStopped(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onExtensionError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onExtensionError(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserAccountUpdated impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserAccountUpdated(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalVideoTranscoderError impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalVideoTranscoderError(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onVideoRenderingTracingResult impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoRenderingTracingResult(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onJoinChannelSuccessEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onJoinChannelSuccessEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onRejoinChannelSuccessEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRejoinChannelSuccessEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioQualityEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioQualityEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onAudioVolumeIndicationEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onAudioVolumeIndicationEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onLeaveChannelEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onLeaveChannelEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onRtcStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtcStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onNetworkQualityEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onNetworkQualityEx(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onIntraRequestReceivedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onIntraRequestReceivedEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstLocalVideoFramePublishedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstLocalVideoFramePublishedEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstRemoteVideoDecodedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onFirstRemoteVideoDecodedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onVideoSizeChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoSizeChangedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalVideoStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalVideoStateChangedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteVideoStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onRemoteVideoStateChangedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onFirstRemoteVideoFrameEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onFirstRemoteVideoFrameEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUserJoinedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onUserJoinedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUserOfflineEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onUserOfflineEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUserMuteAudioEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onUserMuteAudioEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUserMuteVideoEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onUserMuteVideoEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUserEnableVideoEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserEnableVideoEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserEnableLocalVideoEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserEnableLocalVideoEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserStateChangedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalAudioStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalAudioStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteAudioStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onLocalVideoStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalVideoStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteVideoStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onConnectionLostEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onConnectionLostEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onConnectionInterruptedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onConnectionInterruptedEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onConnectionBannedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onConnectionBannedEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onStreamMessageEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onStreamMessageEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onStreamMessageErrorEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onStreamMessageErrorEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRequestTokenEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onRequestTokenEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onLicenseValidationFailureEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLicenseValidationFailureEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onTokenPrivilegeWillExpireEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onTokenPrivilegeWillExpireEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onFirstLocalAudioFramePublishedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstLocalAudioFramePublishedEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onFirstRemoteAudioFrameEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onFirstRemoteAudioFrameEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onFirstRemoteAudioDecodedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onFirstRemoteAudioDecodedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onLocalAudioStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onLocalAudioStateChangedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onRemoteAudioStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onRemoteAudioStateChangedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onActiveSpeakerEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onActiveSpeakerEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onClientRoleChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onClientRoleChangedEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onClientRoleChangeFailedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onClientRoleChangeFailedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteAudioTransportStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioTransportStatsEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onRemoteVideoTransportStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoTransportStatsEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onConnectionStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onConnectionStateChangedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onWlAccMessageEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccMessageEx(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onWlAccStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccStatsEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onNetworkTypeChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onNetworkTypeChangedEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onEncryptionErrorEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    eventHandler.onEncryptionErrorEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
  });
  test('RtcEngineEventHandler_onUploadLogResultEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUploadLogResultEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onUserAccountUpdatedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserAccountUpdatedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onSnapshotTakenEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onSnapshotTakenEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('RtcEngineEventHandler_onVideoRenderingTracingResultEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandler(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoRenderingTracingResultEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
describe('IVideoDeviceManager', () => {
  test('VideoDeviceManager_enumerateVideoDevices impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'enumerateVideoDevices'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_enumerateVideoDevices',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .enumerateVideoDevices
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        .enumerateVideoDevices
    ).toBeCalledWith();
  });

  test('VideoDeviceManager_setDevice parameter', async () => {
    let nParam = {
      deviceIdUTF8: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'VideoDeviceManager_setDevice',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('deviceIdUTF8 is undefined');
    }
    //@ts-ignore
    nParam.deviceIdUTF8 = 'test';
  });

  test('VideoDeviceManager_setDevice impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'setDevice'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceIdUTF8: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_setDevice',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.setDevice
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.setDevice
    ).toBeCalledWith('test');
  });

  test('VideoDeviceManager_getDevice impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'getDevice'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_getDevice',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.getDevice
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.getDevice
    ).toBeCalledWith();
  });

  test('VideoDeviceManager_numberOfCapabilities impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceIdUTF8: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_numberOfCapabilities',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        ?.numberOfCapabilities
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('VideoDeviceManager_getCapability impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceIdUTF8: 'test',
      deviceCapabilityNumber: 'test',
      capability: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_getCapability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        ?.getCapability
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('VideoDeviceManager_startDeviceTest impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      hwnd: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_startDeviceTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        ?.startDeviceTest
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('VideoDeviceManager_stopDeviceTest impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_stopDeviceTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl
        ?.stopDeviceTest
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('VideoDeviceManager_release impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl,
        'release'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'VideoDeviceManager_release',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.release
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('VideoDeviceManager')._impl.release
    ).toBeCalledWith();
  });
});
describe('IMetadataObserver', () => {
  test('MetadataObserver_getMaxMetadataSize impl call', async () => {
    let eventHandler = new bindingAPI.IMetadataObserver(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.getMaxMetadataSize();
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('MetadataObserver_onReadyToSendMetadata impl call', async () => {
    let eventHandler = new bindingAPI.IMetadataObserver(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onReadyToSendMetadata(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('MetadataObserver_onMetadataReceived impl call', async () => {
    let eventHandler = new bindingAPI.IMetadataObserver(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onMetadataReceived(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
describe('IDirectCdnStreamingEventHandler', () => {
  test('DirectCdnStreamingEventHandler_onDirectCdnStreamingStateChanged impl call', async () => {
    let eventHandler = new bindingAPI.IDirectCdnStreamingEventHandler(
      irisRtcEngine
    );
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onDirectCdnStreamingStateChanged(
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('DirectCdnStreamingEventHandler_onDirectCdnStreamingStats impl call', async () => {
    let eventHandler = new bindingAPI.IDirectCdnStreamingEventHandler(
      irisRtcEngine
    );
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onDirectCdnStreamingStats(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
describe('IRtcEngine', () => {
  test('RtcEngine_initialize parameter', async () => {
    let nParam = {
      context: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_initialize',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('context is undefined');
    }
    //@ts-ignore
    nParam.context = 'test';
  });

  test('RtcEngine_initialize impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'initialize'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      context: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_initialize',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.initialize
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.initialize
    ).toBeCalledWith('test');
  });

  test('RtcEngine_queryInterface impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      iid: 'test',
      inter: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_queryInterface',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.queryInterface
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getVersion impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getVersion',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getVersion
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getErrorDescription impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      code: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getErrorDescription',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getErrorDescription
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_queryCodecCapability impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      codecInfo: 'test',
      size: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_queryCodecCapability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.queryCodecCapability
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_preloadChannel impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      uid: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_preloadChannel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.preloadChannel
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_preloadChannel2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_preloadChannel2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.preloadChannel2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_updatePreloadChannelToken impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updatePreloadChannelToken',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updatePreloadChannelToken
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_joinChannel parameter', async () => {
    let nParam = {
      token: undefined,
      channelId: undefined,
      info: undefined,
      uid: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('token is undefined');
    }
    //@ts-ignore
    nParam.token = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('channelId is undefined');
    }
    //@ts-ignore
    nParam.channelId = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('info is undefined');
    }
    //@ts-ignore
    nParam.info = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
  });

  test('RtcEngine_joinChannel impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannel'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      info: 'test',
      uid: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('RtcEngine_joinChannel2 parameter', async () => {
    let nParam = {
      token: undefined,
      channelId: undefined,
      uid: undefined,
      options: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('token is undefined');
    }
    //@ts-ignore
    nParam.token = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('channelId is undefined');
    }
    //@ts-ignore
    nParam.channelId = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannel2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
  });

  test('RtcEngine_joinChannel2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannel2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      uid: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannel2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.joinChannel2
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('RtcEngine_updateChannelMediaOptions parameter', async () => {
    let nParam = {
      options: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_updateChannelMediaOptions',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
  });

  test('RtcEngine_updateChannelMediaOptions impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'updateChannelMediaOptions'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateChannelMediaOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateChannelMediaOptions
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .updateChannelMediaOptions
    ).toBeCalledWith('test');
  });

  test('RtcEngine_leaveChannel impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'leaveChannel'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_leaveChannel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel
    ).toBeCalledWith();
  });

  test('RtcEngine_leaveChannel2 parameter', async () => {
    let nParam = {
      options: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_leaveChannel2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
  });

  test('RtcEngine_leaveChannel2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'leaveChannel2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_leaveChannel2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.leaveChannel2
    ).toBeCalledWith('test');
  });

  test('RtcEngine_renewToken impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_renewToken',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.renewToken
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setChannelProfile parameter', async () => {
    let nParam = {
      profile: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setChannelProfile',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('profile is undefined');
    }
    //@ts-ignore
    nParam.profile = 'test';
  });

  test('RtcEngine_setChannelProfile impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setChannelProfile'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setChannelProfile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setChannelProfile
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setChannelProfile
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setClientRole parameter', async () => {
    let nParam = {
      role: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setClientRole',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('role is undefined');
    }
    //@ts-ignore
    nParam.role = 'test';
  });

  test('RtcEngine_setClientRole impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setClientRole'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      role: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setClientRole',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setClientRole2 parameter', async () => {
    let nParam = {
      role: undefined,
      options: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setClientRole2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('role is undefined');
    }
    //@ts-ignore
    nParam.role = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setClientRole2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
  });

  test('RtcEngine_setClientRole2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setClientRole2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      role: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setClientRole2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setClientRole2
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngine_startEchoTest impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startEchoTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.startEchoTest
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startEchoTest2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      intervalInSeconds: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startEchoTest2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.startEchoTest2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startEchoTest3 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startEchoTest3',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.startEchoTest3
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopEchoTest impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopEchoTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.stopEchoTest
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableMultiCamera impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableMultiCamera',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.enableMultiCamera
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableVideo
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableVideo
    ).toBeCalledWith();
  });

  test('RtcEngine_disableVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'disableVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_disableVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableVideo
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableVideo
    ).toBeCalledWith();
  });

  test('RtcEngine_startPreview impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startPreview'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startPreview',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview
    ).toBeCalledWith();
  });

  test('RtcEngine_startPreview2 parameter', async () => {
    let nParam = {
      sourceType: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_startPreview2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('sourceType is undefined');
    }
    //@ts-ignore
    nParam.sourceType = 'test';
  });

  test('RtcEngine_startPreview2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startPreview2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startPreview2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startPreview2
    ).toBeCalledWith('test');
  });

  test('RtcEngine_stopPreview impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopPreview'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopPreview',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview
    ).toBeCalledWith();
  });

  test('RtcEngine_stopPreview2 parameter', async () => {
    let nParam = {
      sourceType: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_stopPreview2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('sourceType is undefined');
    }
    //@ts-ignore
    nParam.sourceType = 'test';
  });

  test('RtcEngine_stopPreview2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopPreview2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopPreview2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopPreview2
    ).toBeCalledWith('test');
  });

  test('RtcEngine_startLastmileProbeTest impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startLastmileProbeTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startLastmileProbeTest
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopLastmileProbeTest impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopLastmileProbeTest',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.stopLastmileProbeTest
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setVideoEncoderConfiguration parameter', async () => {
    let nParam = {
      config: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setVideoEncoderConfiguration',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('config is undefined');
    }
    //@ts-ignore
    nParam.config = 'test';
  });

  test('RtcEngine_setVideoEncoderConfiguration impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setVideoEncoderConfiguration'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVideoEncoderConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVideoEncoderConfiguration
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setVideoEncoderConfiguration
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setBeautyEffectOptions impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setBeautyEffectOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setBeautyEffectOptions
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLowlightEnhanceOptions impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLowlightEnhanceOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setLowlightEnhanceOptions
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setVideoDenoiserOptions impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVideoDenoiserOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setVideoDenoiserOptions
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setColorEnhanceOptions impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      options: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setColorEnhanceOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setColorEnhanceOptions
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableVirtualBackground impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      backgroundSource: 'test',
      segproperty: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableVirtualBackground',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableVirtualBackground
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setupRemoteVideo impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      canvas: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setupRemoteVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setupRemoteVideo
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setupLocalVideo parameter', async () => {
    let nParam = {
      canvas: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setupLocalVideo',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('canvas is undefined');
    }
    //@ts-ignore
    nParam.canvas = 'test';
  });

  test('RtcEngine_setupLocalVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setupLocalVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      canvas: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setupLocalVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setupLocalVideo
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setupLocalVideo
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setVideoScenario impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      scenarioType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVideoScenario',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setVideoScenario
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableAudio
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableAudio
    ).toBeCalledWith();
  });

  test('RtcEngine_disableAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'disableAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_disableAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableAudio
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.disableAudio
    ).toBeCalledWith();
  });

  test('RtcEngine_setAudioProfile parameter', async () => {
    let nParam = {
      profile: undefined,
      scenario: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setAudioProfile',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('profile is undefined');
    }
    //@ts-ignore
    nParam.profile = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setAudioProfile',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('scenario is undefined');
    }
    //@ts-ignore
    nParam.scenario = 'test';
  });

  test('RtcEngine_setAudioProfile impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioProfile'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
      scenario: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioProfile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngine_setAudioProfile2 parameter', async () => {
    let nParam = {
      profile: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setAudioProfile2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('profile is undefined');
    }
    //@ts-ignore
    nParam.profile = 'test';
  });

  test('RtcEngine_setAudioProfile2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setAudioProfile2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioProfile2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setAudioProfile2
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setAudioScenario impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      scenario: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioScenario',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setAudioScenario
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableLocalAudio parameter', async () => {
    let nParam = {
      enabled: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_enableLocalAudio',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('enabled is undefined');
    }
    //@ts-ignore
    nParam.enabled = 'test';
  });

  test('RtcEngine_enableLocalAudio impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableLocalAudio'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableLocalAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableLocalAudio
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableLocalAudio
    ).toBeCalledWith('test');
  });

  test('RtcEngine_muteLocalAudioStream parameter', async () => {
    let nParam = {
      mute: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteLocalAudioStream',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
  });

  test('RtcEngine_muteLocalAudioStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteLocalAudioStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteLocalAudioStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteLocalAudioStream
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteLocalAudioStream
    ).toBeCalledWith('test');
  });

  test('RtcEngine_muteAllRemoteAudioStreams parameter', async () => {
    let nParam = {
      mute: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteAllRemoteAudioStreams',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
  });

  test('RtcEngine_muteAllRemoteAudioStreams impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteAllRemoteAudioStreams'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteAllRemoteAudioStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteAllRemoteAudioStreams
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteAllRemoteAudioStreams
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setDefaultMuteAllRemoteAudioStreams impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDefaultMuteAllRemoteAudioStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setDefaultMuteAllRemoteAudioStreams
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_muteRemoteAudioStream parameter', async () => {
    let nParam = {
      uid: undefined,
      mute: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteRemoteAudioStream',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteRemoteAudioStream',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
  });

  test('RtcEngine_muteRemoteAudioStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteRemoteAudioStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteRemoteAudioStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteRemoteAudioStream
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteRemoteAudioStream
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngine_muteLocalVideoStream parameter', async () => {
    let nParam = {
      mute: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteLocalVideoStream',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
  });

  test('RtcEngine_muteLocalVideoStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteLocalVideoStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteLocalVideoStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteLocalVideoStream
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteLocalVideoStream
    ).toBeCalledWith('test');
  });

  test('RtcEngine_enableLocalVideo parameter', async () => {
    let nParam = {
      enabled: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_enableLocalVideo',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('enabled is undefined');
    }
    //@ts-ignore
    nParam.enabled = 'test';
  });

  test('RtcEngine_enableLocalVideo impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableLocalVideo'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableLocalVideo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableLocalVideo
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.enableLocalVideo
    ).toBeCalledWith('test');
  });

  test('RtcEngine_muteAllRemoteVideoStreams parameter', async () => {
    let nParam = {
      mute: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteAllRemoteVideoStreams',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
  });

  test('RtcEngine_muteAllRemoteVideoStreams impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteAllRemoteVideoStreams'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteAllRemoteVideoStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteAllRemoteVideoStreams
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteAllRemoteVideoStreams
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setDefaultMuteAllRemoteVideoStreams impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDefaultMuteAllRemoteVideoStreams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setDefaultMuteAllRemoteVideoStreams
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_muteRemoteVideoStream parameter', async () => {
    let nParam = {
      uid: undefined,
      mute: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteRemoteVideoStream',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_muteRemoteVideoStream',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
  });

  test('RtcEngine_muteRemoteVideoStream impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'muteRemoteVideoStream'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteRemoteVideoStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteRemoteVideoStream
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .muteRemoteVideoStream
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngine_setRemoteVideoStreamType impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      streamType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteVideoStreamType',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRemoteVideoStreamType
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setRemoteVideoSubscriptionOptions impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteVideoSubscriptionOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRemoteVideoSubscriptionOptions
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setRemoteDefaultVideoStreamType impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteDefaultVideoStreamType',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRemoteDefaultVideoStreamType
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setSubscribeAudioBlocklist impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeAudioBlocklist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setSubscribeAudioBlocklist
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setSubscribeAudioAllowlist impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeAudioAllowlist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setSubscribeAudioAllowlist
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setSubscribeVideoBlocklist impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeVideoBlocklist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setSubscribeVideoBlocklist
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setSubscribeVideoAllowlist impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setSubscribeVideoAllowlist',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setSubscribeVideoAllowlist
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableAudioVolumeIndication parameter', async () => {
    let nParam = {
      interval: undefined,
      smooth: undefined,
      reportVad: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_enableAudioVolumeIndication',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('interval is undefined');
    }
    //@ts-ignore
    nParam.interval = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_enableAudioVolumeIndication',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('smooth is undefined');
    }
    //@ts-ignore
    nParam.smooth = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_enableAudioVolumeIndication',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('reportVad is undefined');
    }
    //@ts-ignore
    nParam.reportVad = 'test';
  });

  test('RtcEngine_enableAudioVolumeIndication impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'enableAudioVolumeIndication'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      interval: 'test',
      smooth: 'test',
      reportVad: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableAudioVolumeIndication',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableAudioVolumeIndication
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .enableAudioVolumeIndication
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('RtcEngine_startAudioRecording impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      quality: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioRecording',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startAudioRecording
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startAudioRecording2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      sampleRate: 'test',
      quality: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioRecording2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startAudioRecording2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startAudioRecording3 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioRecording3',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startAudioRecording3
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_registerAudioEncodedFrameObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerAudioEncodedFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.registerAudioEncodedFrameObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopAudioRecording impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAudioRecording',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.stopAudioRecording
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_createMediaPlayer impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createMediaPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.createMediaPlayer
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_destroyMediaPlayer impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      media_player: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyMediaPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.destroyMediaPlayer
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_createMediaRecorder impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      info: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createMediaRecorder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.createMediaRecorder
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_destroyMediaRecorder impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mediaRecorder: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyMediaRecorder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.destroyMediaRecorder
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startAudioMixing impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      loopback: 'test',
      cycle: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.startAudioMixing
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startAudioMixing2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
      loopback: 'test',
      cycle: 'test',
      startPos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioMixing2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.startAudioMixing2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopAudioMixing impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.stopAudioMixing
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_pauseAudioMixing impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.pauseAudioMixing
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_resumeAudioMixing impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAudioMixing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.resumeAudioMixing
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_selectAudioTrack impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      index: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_selectAudioTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.selectAudioTrack
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getAudioTrackCount impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioTrackCount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getAudioTrackCount
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustAudioMixingVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustAudioMixingVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustAudioMixingVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustAudioMixingPublishVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustAudioMixingPublishVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustAudioMixingPublishVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getAudioMixingPublishVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingPublishVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getAudioMixingPublishVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustAudioMixingPlayoutVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustAudioMixingPlayoutVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustAudioMixingPlayoutVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getAudioMixingPlayoutVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingPlayoutVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getAudioMixingPlayoutVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getAudioMixingDuration impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingDuration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getAudioMixingDuration
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getAudioMixingCurrentPosition impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioMixingCurrentPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getAudioMixingCurrentPosition
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAudioMixingPosition impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      pos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioMixingPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setAudioMixingPosition
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAudioMixingDualMonoMode impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioMixingDualMonoMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setAudioMixingDualMonoMode
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAudioMixingPitch impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      pitch: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioMixingPitch',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setAudioMixingPitch
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getEffectsVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getEffectsVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getEffectsVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setEffectsVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEffectsVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setEffectsVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_preloadEffect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      filePath: 'test',
      startPos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_preloadEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.preloadEffect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_playEffect parameter', async () => {
    let nParam = {
      soundId: undefined,
      filePath: undefined,
      loopCount: undefined,
      pitch: undefined,
      pan: undefined,
      gain: undefined,
      publish: undefined,
      startPos: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('soundId is undefined');
    }
    //@ts-ignore
    nParam.soundId = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('filePath is undefined');
    }
    //@ts-ignore
    nParam.filePath = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('loopCount is undefined');
    }
    //@ts-ignore
    nParam.loopCount = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('pitch is undefined');
    }
    //@ts-ignore
    nParam.pitch = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('pan is undefined');
    }
    //@ts-ignore
    nParam.pan = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('gain is undefined');
    }
    //@ts-ignore
    nParam.gain = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('publish is undefined');
    }
    //@ts-ignore
    nParam.publish = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_playEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('startPos is undefined');
    }
    //@ts-ignore
    nParam.startPos = 'test';
  });

  test('RtcEngine_playEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'playEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      filePath: 'test',
      loopCount: 'test',
      pitch: 'test',
      pan: 'test',
      gain: 'test',
      publish: 'test',
      startPos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_playEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.playEffect
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.playEffect
    ).toBeCalledWith(
      'test',
      'test',
      'test',
      'test',
      'test',
      'test',
      'test',
      'test'
    );
  });

  test('RtcEngine_playAllEffects impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      loopCount: 'test',
      pitch: 'test',
      pan: 'test',
      gain: 'test',
      publish: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_playAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.playAllEffects
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getVolumeOfEffect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getVolumeOfEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getVolumeOfEffect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setVolumeOfEffect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVolumeOfEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setVolumeOfEffect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_pauseEffect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.pauseEffect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_pauseAllEffects impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.pauseAllEffects
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_resumeEffect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.resumeEffect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_resumeAllEffects impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.resumeAllEffects
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopEffect parameter', async () => {
    let nParam = {
      soundId: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_stopEffect',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('soundId is undefined');
    }
    //@ts-ignore
    nParam.soundId = 'test';
  });

  test('RtcEngine_stopEffect impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopEffect'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopEffect
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopEffect
    ).toBeCalledWith('test');
  });

  test('RtcEngine_stopAllEffects impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopAllEffects'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopAllEffects
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopAllEffects
    ).toBeCalledWith();
  });

  test('RtcEngine_unloadEffect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unloadEffect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.unloadEffect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_unloadAllEffects impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unloadAllEffects',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.unloadAllEffects
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getEffectDuration impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getEffectDuration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getEffectDuration
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setEffectPosition impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
      pos: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEffectPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setEffectPosition
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getEffectCurrentPosition impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      soundId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getEffectCurrentPosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getEffectCurrentPosition
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableSoundPositionIndication impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableSoundPositionIndication',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableSoundPositionIndication
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setRemoteVoicePosition impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      pan: 'test',
      gain: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteVoicePosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRemoteVoicePosition
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableSpatialAudio impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableSpatialAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.enableSpatialAudio
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setRemoteUserSpatialAudioParams impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      params: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteUserSpatialAudioParams',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRemoteUserSpatialAudioParams
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setVoiceBeautifierPreset impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceBeautifierPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setVoiceBeautifierPreset
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAudioEffectPreset impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioEffectPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setAudioEffectPreset
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setVoiceConversionPreset impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceConversionPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setVoiceConversionPreset
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAudioEffectParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
      param1: 'test',
      param2: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioEffectParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setAudioEffectParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setVoiceBeautifierParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
      param1: 'test',
      param2: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceBeautifierParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setVoiceBeautifierParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setVoiceConversionParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
      param1: 'test',
      param2: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setVoiceConversionParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setVoiceConversionParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLocalVoicePitch impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      pitch: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoicePitch',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setLocalVoicePitch
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLocalVoiceFormant impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      formantRatio: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoiceFormant',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setLocalVoiceFormant
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLocalVoiceEqualization impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      bandFrequency: 'test',
      bandGain: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoiceEqualization',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setLocalVoiceEqualization
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLocalVoiceReverb impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      reverbKey: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVoiceReverb',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setLocalVoiceReverb
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setHeadphoneEQPreset impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      preset: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setHeadphoneEQPreset',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setHeadphoneEQPreset
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setHeadphoneEQParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      lowGain: 'test',
      highGain: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setHeadphoneEQParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setHeadphoneEQParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLogFile impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogFile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setLogFile
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLogFilter impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      filter: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogFilter',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setLogFilter
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLogLevel parameter', async () => {
    let nParam = {
      level: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setLogLevel',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('level is undefined');
    }
    //@ts-ignore
    nParam.level = 'test';
  });

  test('RtcEngine_setLogLevel impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLogLevel'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      level: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogLevel',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLogLevel
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLogLevel
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setLogFileSize impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      fileSizeInKBytes: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLogFileSize',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setLogFileSize
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_uploadLogFile impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      requestId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_uploadLogFile',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.uploadLogFile
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLocalRenderMode parameter', async () => {
    let nParam = {
      renderMode: undefined,
      mirrorMode: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setLocalRenderMode',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('renderMode is undefined');
    }
    //@ts-ignore
    nParam.renderMode = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setLocalRenderMode',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mirrorMode is undefined');
    }
    //@ts-ignore
    nParam.mirrorMode = 'test';
  });

  test('RtcEngine_setLocalRenderMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalRenderMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      renderMode: 'test',
      mirrorMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalRenderMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalRenderMode
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalRenderMode
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngine_setRemoteRenderMode parameter', async () => {
    let nParam = {
      uid: undefined,
      renderMode: undefined,
      mirrorMode: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setRemoteRenderMode',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setRemoteRenderMode',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('renderMode is undefined');
    }
    //@ts-ignore
    nParam.renderMode = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setRemoteRenderMode',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mirrorMode is undefined');
    }
    //@ts-ignore
    nParam.mirrorMode = 'test';
  });

  test('RtcEngine_setRemoteRenderMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setRemoteRenderMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      renderMode: 'test',
      mirrorMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteRenderMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setRemoteRenderMode
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setRemoteRenderMode
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('RtcEngine_setLocalRenderMode2 parameter', async () => {
    let nParam = {
      renderMode: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setLocalRenderMode2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('renderMode is undefined');
    }
    //@ts-ignore
    nParam.renderMode = 'test';
  });

  test('RtcEngine_setLocalRenderMode2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalRenderMode2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      renderMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalRenderMode2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalRenderMode2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setLocalRenderMode2
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setLocalVideoMirrorMode parameter', async () => {
    let nParam = {
      mirrorMode: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setLocalVideoMirrorMode',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mirrorMode is undefined');
    }
    //@ts-ignore
    nParam.mirrorMode = 'test';
  });

  test('RtcEngine_setLocalVideoMirrorMode impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setLocalVideoMirrorMode'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mirrorMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalVideoMirrorMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setLocalVideoMirrorMode
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setLocalVideoMirrorMode
    ).toBeCalledWith('test');
  });

  test('RtcEngine_enableDualStreamMode impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableDualStreamMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableDualStreamMode
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableDualStreamMode2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      streamConfig: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableDualStreamMode2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableDualStreamMode2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setDualStreamMode impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDualStreamMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setDualStreamMode
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setDualStreamMode2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
      streamConfig: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDualStreamMode2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setDualStreamMode2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableCustomAudioLocalPlayback impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableCustomAudioLocalPlayback',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableCustomAudioLocalPlayback
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setRecordingAudioFrameParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      mode: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRecordingAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRecordingAudioFrameParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setPlaybackAudioFrameParameters parameter', async () => {
    let nParam = {
      sampleRate: undefined,
      channel: undefined,
      mode: undefined,
      samplesPerCall: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setPlaybackAudioFrameParameters',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('sampleRate is undefined');
    }
    //@ts-ignore
    nParam.sampleRate = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setPlaybackAudioFrameParameters',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('channel is undefined');
    }
    //@ts-ignore
    nParam.channel = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setPlaybackAudioFrameParameters',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mode is undefined');
    }
    //@ts-ignore
    nParam.mode = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setPlaybackAudioFrameParameters',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('samplesPerCall is undefined');
    }
    //@ts-ignore
    nParam.samplesPerCall = 'test';
  });

  test('RtcEngine_setPlaybackAudioFrameParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setPlaybackAudioFrameParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      mode: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setPlaybackAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setPlaybackAudioFrameParameters
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .setPlaybackAudioFrameParameters
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('RtcEngine_setMixedAudioFrameParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setMixedAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setMixedAudioFrameParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setEarMonitoringAudioFrameParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
      mode: 'test',
      samplesPerCall: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEarMonitoringAudioFrameParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setEarMonitoringAudioFrameParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setPlaybackAudioFrameBeforeMixingParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sampleRate: 'test',
      channel: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setPlaybackAudioFrameBeforeMixingParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setPlaybackAudioFrameBeforeMixingParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableAudioSpectrumMonitor impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      intervalInMS: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableAudioSpectrumMonitor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableAudioSpectrumMonitor
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_disableAudioSpectrumMonitor impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_disableAudioSpectrumMonitor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.disableAudioSpectrumMonitor
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_registerAudioSpectrumObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerAudioSpectrumObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.registerAudioSpectrumObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_unregisterAudioSpectrumObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unregisterAudioSpectrumObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.unregisterAudioSpectrumObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustRecordingSignalVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustRecordingSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustRecordingSignalVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_muteRecordingSignal impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_muteRecordingSignal',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.muteRecordingSignal
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustPlaybackSignalVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustPlaybackSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustPlaybackSignalVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustUserPlaybackSignalVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustUserPlaybackSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustUserPlaybackSignalVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLocalPublishFallbackOption impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalPublishFallbackOption',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setLocalPublishFallbackOption
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setRemoteSubscribeFallbackOption impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteSubscribeFallbackOption',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRemoteSubscribeFallbackOption
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setHighPriorityUserList impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNum: 'test',
      option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setHighPriorityUserList',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setHighPriorityUserList
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableLoopbackRecording impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      deviceName: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableLoopbackRecording',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableLoopbackRecording
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustLoopbackSignalVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustLoopbackSignalVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustLoopbackSignalVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getLoopbackRecordingVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getLoopbackRecordingVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getLoopbackRecordingVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableInEarMonitoring impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      includeAudioFilters: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableInEarMonitoring',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableInEarMonitoring
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setInEarMonitoringVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setInEarMonitoringVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setInEarMonitoringVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_loadExtensionProvider impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      path: 'test',
      unload_after_use: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_loadExtensionProvider',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.loadExtensionProvider
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setExtensionProviderProperty impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      key: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setExtensionProviderProperty',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setExtensionProviderProperty
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_registerExtension impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerExtension',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.registerExtension
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableExtension impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      enable: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableExtension',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.enableExtension
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableExtension2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      extensionInfo: 'test',
      enable: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableExtension2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.enableExtension2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setExtensionProperty impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      key: 'test',
      value: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setExtensionProperty',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setExtensionProperty
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getExtensionProperty impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      key: 'test',
      value: 'test',
      buf_len: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getExtensionProperty',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getExtensionProperty
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setExtensionProperty2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      extensionInfo: 'test',
      key: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setExtensionProperty2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setExtensionProperty2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getExtensionProperty2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      provider: 'test',
      extension: 'test',
      extensionInfo: 'test',
      key: 'test',
      value: 'test',
      buf_len: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getExtensionProperty2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getExtensionProperty2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraCapturerConfiguration impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraCapturerConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraCapturerConfiguration
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_createCustomVideoTrack impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createCustomVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.createCustomVideoTrack
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_createCustomEncodedVideoTrack impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sender_option: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createCustomEncodedVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.createCustomEncodedVideoTrack
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_destroyCustomVideoTrack impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      video_track_id: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyCustomVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.destroyCustomVideoTrack
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_destroyCustomEncodedVideoTrack impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      video_track_id: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_destroyCustomEncodedVideoTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.destroyCustomEncodedVideoTrack
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_switchCamera impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_switchCamera',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.switchCamera
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraZoomSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraZoomSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraZoomSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraFaceDetectSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraFaceDetectSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraFaceDetectSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraTorchSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraTorchSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraTorchSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraFocusSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraFocusSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraFocusSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraAutoFocusFaceModeSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraAutoFocusFaceModeSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraAutoFocusFaceModeSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraZoomFactor impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      factor: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraZoomFactor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraZoomFactor
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableFaceDetection impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableFaceDetection',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableFaceDetection
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getCameraMaxZoomFactor impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getCameraMaxZoomFactor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getCameraMaxZoomFactor
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraFocusPositionInPreview impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      positionX: 'test',
      positionY: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraFocusPositionInPreview',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraFocusPositionInPreview
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraTorchOn impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      isOn: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraTorchOn',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setCameraTorchOn
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraAutoFocusFaceModeEnabled impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraAutoFocusFaceModeEnabled',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraAutoFocusFaceModeEnabled
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraExposurePositionSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraExposurePositionSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraExposurePositionSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraExposurePosition impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      positionXinView: 'test',
      positionYinView: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraExposurePosition',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraExposurePosition
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraExposureSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraExposureSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraExposureSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraExposureFactor impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      factor: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraExposureFactor',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraExposureFactor
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isCameraAutoExposureFaceModeSupported impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isCameraAutoExposureFaceModeSupported',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isCameraAutoExposureFaceModeSupported
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraAutoExposureFaceModeEnabled impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraAutoExposureFaceModeEnabled',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraAutoExposureFaceModeEnabled
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setDefaultAudioRouteToSpeakerphone impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      defaultToSpeaker: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDefaultAudioRouteToSpeakerphone',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setDefaultAudioRouteToSpeakerphone
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setEnableSpeakerphone impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      speakerOn: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEnableSpeakerphone',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setEnableSpeakerphone
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isSpeakerphoneEnabled impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isSpeakerphoneEnabled',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isSpeakerphoneEnabled
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setRouteInCommunicationMode impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      route: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRouteInCommunicationMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRouteInCommunicationMode
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getScreenCaptureSources impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      thumbSize: 'test',
      iconSize: 'test',
      includeScreen: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getScreenCaptureSources',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getScreenCaptureSources
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAudioSessionOperationRestriction impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      restriction: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAudioSessionOperationRestriction',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setAudioSessionOperationRestriction
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startScreenCaptureByDisplayId impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      displayId: 'test',
      regionRect: 'test',
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCaptureByDisplayId',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startScreenCaptureByDisplayId
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startScreenCaptureByScreenRect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      screenRect: 'test',
      regionRect: 'test',
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCaptureByScreenRect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startScreenCaptureByScreenRect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getAudioDeviceInfo impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      deviceInfo: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getAudioDeviceInfo',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getAudioDeviceInfo
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startScreenCaptureByWindowId impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      windowId: 'test',
      regionRect: 'test',
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCaptureByWindowId',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startScreenCaptureByWindowId
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setScreenCaptureContentHint impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      contentHint: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setScreenCaptureContentHint',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setScreenCaptureContentHint
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_updateScreenCaptureRegion impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      regionRect: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateScreenCaptureRegion',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updateScreenCaptureRegion
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_updateScreenCaptureParameters impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateScreenCaptureParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updateScreenCaptureParameters
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startScreenCapture parameter', async () => {
    let nParam = {
      captureParams: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_startScreenCapture',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('captureParams is undefined');
    }
    //@ts-ignore
    nParam.captureParams = 'test';
  });

  test('RtcEngine_startScreenCapture impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'startScreenCapture'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startScreenCapture
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.startScreenCapture
    ).toBeCalledWith('test');
  });

  test('RtcEngine_updateScreenCapture impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      captureParams: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateScreenCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updateScreenCapture
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_queryScreenCaptureCapability impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_queryScreenCaptureCapability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.queryScreenCaptureCapability
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setScreenCaptureScenario impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      screenScenario: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setScreenCaptureScenario',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setScreenCaptureScenario
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopScreenCapture impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopScreenCapture'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopScreenCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture
    ).toBeCalledWith();
  });

  test('RtcEngine_getCallId impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      callId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getCallId',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getCallId
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_rate impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      callId: 'test',
      rating: 'test',
      description: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_rate',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.rate
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_complain impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      callId: 'test',
      description: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_complain',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.complain
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startRtmpStreamWithoutTranscoding impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startRtmpStreamWithoutTranscoding',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startRtmpStreamWithoutTranscoding
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startRtmpStreamWithTranscoding impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      transcoding: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startRtmpStreamWithTranscoding',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startRtmpStreamWithTranscoding
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_updateRtmpTranscoding impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      transcoding: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateRtmpTranscoding',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updateRtmpTranscoding
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopRtmpStream impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopRtmpStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.stopRtmpStream
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startLocalVideoTranscoder impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startLocalVideoTranscoder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startLocalVideoTranscoder
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_updateLocalTranscoderConfiguration impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateLocalTranscoderConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updateLocalTranscoderConfiguration
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopLocalVideoTranscoder impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopLocalVideoTranscoder',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.stopLocalVideoTranscoder
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startCameraCapture impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startCameraCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.startCameraCapture
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopCameraCapture impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopCameraCapture',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.stopCameraCapture
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCameraDeviceOrientation impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      type: 'test',
      orientation: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCameraDeviceOrientation',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setCameraDeviceOrientation
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setScreenCaptureOrientation impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      type: 'test',
      orientation: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setScreenCaptureOrientation',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setScreenCaptureOrientation
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startScreenCapture2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startScreenCapture2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startScreenCapture2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopScreenCapture2 parameter', async () => {
    let nParam = {
      sourceType: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_stopScreenCapture2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('sourceType is undefined');
    }
    //@ts-ignore
    nParam.sourceType = 'test';
  });

  test('RtcEngine_stopScreenCapture2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'stopScreenCapture2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopScreenCapture2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.stopScreenCapture2
    ).toBeCalledWith('test');
  });

  test('RtcEngine_getConnectionState impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getConnectionState',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getConnectionState
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_registerEventHandler parameter', async () => {
    let nParam = {
      eventHandler: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_registerEventHandler',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('eventHandler is undefined');
    }
    //@ts-ignore
    nParam.eventHandler = 'test';
  });

  test('RtcEngine_registerEventHandler impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'registerEventHandler'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      eventHandler: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerEventHandler',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerEventHandler
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .registerEventHandler
    ).toBeCalledWith('test');
  });

  test('RtcEngine_unregisterEventHandler parameter', async () => {
    let nParam = {
      eventHandler: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_unregisterEventHandler',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('eventHandler is undefined');
    }
    //@ts-ignore
    nParam.eventHandler = 'test';
  });

  test('RtcEngine_unregisterEventHandler impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'unregisterEventHandler'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      eventHandler: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unregisterEventHandler',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .unregisterEventHandler
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .unregisterEventHandler
    ).toBeCalledWith('test');
  });

  test('RtcEngine_setRemoteUserPriority impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      userPriority: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setRemoteUserPriority',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setRemoteUserPriority
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_registerPacketObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerPacketObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.registerPacketObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setEncryptionMode impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      encryptionMode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEncryptionMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setEncryptionMode
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setEncryptionSecret impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      secret: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setEncryptionSecret',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setEncryptionSecret
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableEncryption impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableEncryption',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.enableEncryption
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_createDataStream impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      reliable: 'test',
      ordered: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createDataStream',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.createDataStream
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_createDataStream2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_createDataStream2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.createDataStream2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_sendStreamMessage parameter', async () => {
    let nParam = {
      streamId: 'test',
      data: 'test',
      length: 'test',
    };
    jest.spyOn(bufferExtensions, 'callApiBufferExtension');
    await IrisCore.callIrisApi(
      apiEnginePtr,
      new IrisCore.EventParam(
        'RtcEngine_sendStreamMessage',
        JSON.stringify(nParam),
        0,
        '',
        ['test'],
        [],
        1
      )
    );
    expect(bufferExtensions.callApiBufferExtension).toBeCalledTimes(1);
  });

  test('RtcEngine_sendStreamMessage impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'sendStreamMessage'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      data: 'test',
      length: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_sendStreamMessage',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.sendStreamMessage
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.sendStreamMessage
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('RtcEngine_addVideoWatermark impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      watermark: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_addVideoWatermark',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.addVideoWatermark
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_addVideoWatermark2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      watermarkUrl: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_addVideoWatermark2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.addVideoWatermark2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_clearVideoWatermarks impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_clearVideoWatermarks',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.clearVideoWatermarks
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_pauseAudio impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.pauseAudio
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_resumeAudio impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAudio',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.resumeAudio
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableWebSdkInteroperability impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableWebSdkInteroperability',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableWebSdkInteroperability
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_sendCustomReportMessage impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      id: 'test',
      category: 'test',
      event: 'test',
      label: 'test',
      value: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_sendCustomReportMessage',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.sendCustomReportMessage
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_registerMediaMetadataObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerMediaMetadataObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.registerMediaMetadataObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_unregisterMediaMetadataObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_unregisterMediaMetadataObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.unregisterMediaMetadataObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startAudioFrameDump impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      channel_id: 'test',
      user_id: 'test',
      location: 'test',
      uuid: 'test',
      passwd: 'test',
      duration_ms: 'test',
      auto_upload: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startAudioFrameDump',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startAudioFrameDump
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopAudioFrameDump impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      channel_id: 'test',
      user_id: 'test',
      location: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopAudioFrameDump',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.stopAudioFrameDump
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAINSMode impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      mode: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAINSMode',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setAINSMode
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_registerLocalUserAccount impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      appId: 'test',
      userAccount: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_registerLocalUserAccount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.registerLocalUserAccount
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_joinChannelWithUserAccount parameter', async () => {
    let nParam = {
      token: undefined,
      channelId: undefined,
      userAccount: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannelWithUserAccount',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('token is undefined');
    }
    //@ts-ignore
    nParam.token = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannelWithUserAccount',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('channelId is undefined');
    }
    //@ts-ignore
    nParam.channelId = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannelWithUserAccount',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('userAccount is undefined');
    }
    //@ts-ignore
    nParam.userAccount = 'test';
  });

  test('RtcEngine_joinChannelWithUserAccount impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannelWithUserAccount'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannelWithUserAccount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .joinChannelWithUserAccount
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .joinChannelWithUserAccount
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('RtcEngine_joinChannelWithUserAccount2 parameter', async () => {
    let nParam = {
      token: undefined,
      channelId: undefined,
      userAccount: undefined,
      options: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannelWithUserAccount2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('token is undefined');
    }
    //@ts-ignore
    nParam.token = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannelWithUserAccount2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('channelId is undefined');
    }
    //@ts-ignore
    nParam.channelId = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannelWithUserAccount2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('userAccount is undefined');
    }
    //@ts-ignore
    nParam.userAccount = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_joinChannelWithUserAccount2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
  });

  test('RtcEngine_joinChannelWithUserAccount2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'joinChannelWithUserAccount2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannelWithUserAccount2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .joinChannelWithUserAccount2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .joinChannelWithUserAccount2
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('RtcEngine_joinChannelWithUserAccountEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      channelId: 'test',
      userAccount: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_joinChannelWithUserAccountEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.joinChannelWithUserAccountEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getUserInfoByUserAccount parameter', async () => {
    let nParam = {
      userAccount: undefined,
      userInfo: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_getUserInfoByUserAccount',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('userAccount is undefined');
    }
    //@ts-ignore
    nParam.userAccount = 'test';
  });

  test('RtcEngine_getUserInfoByUserAccount impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getUserInfoByUserAccount'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      userAccount: 'test',
      userInfo: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getUserInfoByUserAccount',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getUserInfoByUserAccount
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        .getUserInfoByUserAccount
    ).toBeCalledWith('test');
  });

  test('RtcEngine_getUserInfoByUid parameter', async () => {
    let nParam = {
      uid: undefined,
      userInfo: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_getUserInfoByUid',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
  });

  test('RtcEngine_getUserInfoByUid impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'getUserInfoByUid'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      userInfo: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getUserInfoByUid',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getUserInfoByUid
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.getUserInfoByUid
    ).toBeCalledWith('test');
  });

  test('RtcEngine_startOrUpdateChannelMediaRelay impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startOrUpdateChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startOrUpdateChannelMediaRelay
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startChannelMediaRelay impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startChannelMediaRelay
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_updateChannelMediaRelay impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updateChannelMediaRelay
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopChannelMediaRelay impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.stopChannelMediaRelay
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_pauseAllChannelMediaRelay impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_pauseAllChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.pauseAllChannelMediaRelay
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_resumeAllChannelMediaRelay impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_resumeAllChannelMediaRelay',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.resumeAllChannelMediaRelay
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setDirectCdnStreamingAudioConfiguration impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      profile: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDirectCdnStreamingAudioConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setDirectCdnStreamingAudioConfiguration
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setDirectCdnStreamingVideoConfiguration impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setDirectCdnStreamingVideoConfiguration',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setDirectCdnStreamingVideoConfiguration
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startDirectCdnStreaming impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      eventHandler: 'test',
      publishUrl: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startDirectCdnStreaming',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startDirectCdnStreaming
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopDirectCdnStreaming impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopDirectCdnStreaming',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.stopDirectCdnStreaming
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_updateDirectCdnStreamingMediaOptions impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_updateDirectCdnStreamingMediaOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.updateDirectCdnStreamingMediaOptions
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_startRhythmPlayer impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      sound1: 'test',
      sound2: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startRhythmPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.startRhythmPlayer
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_stopRhythmPlayer impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_stopRhythmPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.stopRhythmPlayer
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_configRhythmPlayer impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_configRhythmPlayer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.configRhythmPlayer
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_takeSnapshot impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_takeSnapshot',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.takeSnapshot
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableContentInspect impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableContentInspect',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableContentInspect
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustCustomAudioPublishVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustCustomAudioPublishVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustCustomAudioPublishVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_adjustCustomAudioPlayoutVolume impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      volume: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_adjustCustomAudioPlayoutVolume',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.adjustCustomAudioPlayoutVolume
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setCloudProxy impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      proxyType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setCloudProxy',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setCloudProxy
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setLocalAccessPoint impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setLocalAccessPoint',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setLocalAccessPoint
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAdvancedAudioOptions impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
      sourceType: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAdvancedAudioOptions',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.setAdvancedAudioOptions
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setAVSyncSource impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      channelId: 'test',
      uid: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setAVSyncSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.setAVSyncSource
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableVideoImageSource impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enable: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableVideoImageSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableVideoImageSource
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getCurrentMonotonicTimeInMs impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getCurrentMonotonicTimeInMs',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.getCurrentMonotonicTimeInMs
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableWirelessAccelerate impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableWirelessAccelerate',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableWirelessAccelerate
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getNetworkType impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getNetworkType',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getNetworkType
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_setParameters parameter', async () => {
    let nParam = {
      parameters: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngine_setParameters',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('parameters is undefined');
    }
    //@ts-ignore
    nParam.parameters = 'test';
  });

  test('RtcEngine_setParameters impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl,
        'setParameters'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      parameters: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_setParameters',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setParameters
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl.setParameters
    ).toBeCalledWith('test');
  });

  test('RtcEngine_startMediaRenderingTracing impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_startMediaRenderingTracing',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.startMediaRenderingTracing
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_enableInstantMediaRendering impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_enableInstantMediaRendering',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.enableInstantMediaRendering
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_getNtpWallTimeInMs impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_getNtpWallTimeInMs',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl?.getNtpWallTimeInMs
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngine_isFeatureAvailableOnDevice impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      type: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngine_isFeatureAvailableOnDevice',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngine')._impl
        ?.isFeatureAvailableOnDevice
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});

/// Generated by terra, DO NOT MODIFY BY HAND.

import * as NATIVE_RTC from '@iris/native-rtc';
import { CallIrisApiResult, IrisApiEngine, IrisCore } from 'iris-web-core';

import { IrisWebRtc } from '../../src/IrisRtcApi';
import * as bufferExtensions from '../../src/extensions/CallApiBufferExtensions';
import { IrisRtcEngine } from '../engine/IrisRtcEngine';

const bindingAPI = require('../../src/binding/IAgoraMediaEngineDispatch');

let apiEnginePtr: IrisApiEngine;
let irisRtcEngine: IrisRtcEngine;
beforeAll(async () => {
  apiEnginePtr = IrisCore.createIrisApiEngine();
  IrisWebRtc.initIrisRtc(apiEnginePtr);
  irisRtcEngine = apiEnginePtr['apiInterceptors'][0];
  irisRtcEngine.implHelper.createMicrophoneAudioTrack = jest.fn();
  let nParam = {
    context: 'test',
  };
  let apiParam = new IrisCore.EventParam(
    'RtcEngine_initialize',
    JSON.stringify(nParam),
    0,
    '',
    ['test'],
    [],
    1
  );
  await IrisCore.callIrisApi(apiEnginePtr, apiParam);
});

afterAll(() => {
  IrisCore.disposeIrisApiEngine(apiEnginePtr);
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('IMediaEngine', () => {
  test('MediaEngine_registerAudioFrameObserver parameter', async () => {
    let nParam = {
      observer: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'MediaEngine_registerAudioFrameObserver',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('observer is undefined');
    }
    //@ts-ignore
    nParam.observer = 'test';
  });

  test('MediaEngine_registerAudioFrameObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'registerAudioFrameObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_registerAudioFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .registerAudioFrameObserver
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .registerAudioFrameObserver
    ).toBeCalledWith('test');
  });

  test('MediaEngine_registerVideoFrameObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_registerVideoFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.registerVideoFrameObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_registerVideoEncodedFrameObserver impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_registerVideoEncodedFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.registerVideoEncodedFrameObserver
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_pushAudioFrame impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      frame: 'test',
      trackId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_pushAudioFrame',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl?.pushAudioFrame
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_pullAudioFrame impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      frame: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_pullAudioFrame',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl?.pullAudioFrame
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_setExternalVideoSource parameter', async () => {
    let nParam = {
      enabled: undefined,
      useTexture: undefined,
      sourceType: undefined,
      encodedVideoOption: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'MediaEngine_setExternalVideoSource',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('enabled is undefined');
    }
    //@ts-ignore
    nParam.enabled = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'MediaEngine_setExternalVideoSource',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('useTexture is undefined');
    }
    //@ts-ignore
    nParam.useTexture = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'MediaEngine_setExternalVideoSource',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('sourceType is undefined');
    }
    //@ts-ignore
    nParam.sourceType = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'MediaEngine_setExternalVideoSource',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('encodedVideoOption is undefined');
    }
    //@ts-ignore
    nParam.encodedVideoOption = 'test';
  });

  test('MediaEngine_setExternalVideoSource impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'setExternalVideoSource'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      useTexture: 'test',
      sourceType: 'test',
      encodedVideoOption: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_setExternalVideoSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .setExternalVideoSource
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .setExternalVideoSource
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('MediaEngine_setExternalAudioSource impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      sampleRate: 'test',
      channels: 'test',
      localPlayback: 'test',
      publish: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_setExternalAudioSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.setExternalAudioSource
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_createCustomAudioTrack impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackType: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_createCustomAudioTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.createCustomAudioTrack
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_destroyCustomAudioTrack impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_destroyCustomAudioTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.destroyCustomAudioTrack
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_setExternalAudioSink impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      sampleRate: 'test',
      channels: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_setExternalAudioSink',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.setExternalAudioSink
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_enableCustomAudioLocalPlayback impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      enabled: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_enableCustomAudioLocalPlayback',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.enableCustomAudioLocalPlayback
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_pushVideoFrame parameter', async () => {
    let nParam = {
      frame: 'test',
      videoTrackId: 'test',
    };
    jest.spyOn(bufferExtensions, 'callApiBufferExtension');
    await IrisCore.callIrisApi(
      apiEnginePtr,
      new IrisCore.EventParam(
        'MediaEngine_pushVideoFrame',
        JSON.stringify(nParam),
        0,
        '',
        ['test'],
        [],
        1
      )
    );
    expect(bufferExtensions.callApiBufferExtension).toBeCalledTimes(1);
  });

  test('MediaEngine_pushVideoFrame impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'pushVideoFrame'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      frame: 'test',
      videoTrackId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_pushVideoFrame',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl.pushVideoFrame
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl.pushVideoFrame
    ).toBeCalledWith('test', 'test');
  });

  test('MediaEngine_pushEncodedVideoImage impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      imageBuffer: 'test',
      length: 'test',
      videoEncodedFrameInfo: 'test',
      videoTrackId: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_pushEncodedVideoImage',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.pushEncodedVideoImage
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_addVideoFrameRenderer impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      renderer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_addVideoFrameRenderer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.addVideoFrameRenderer
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine_removeVideoFrameRenderer impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      renderer: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'MediaEngine_removeVideoFrameRenderer',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        ?.removeVideoFrameRenderer
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('MediaEngine impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new IrisCore.EventParam(
      'MediaEngine',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl?.release
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});

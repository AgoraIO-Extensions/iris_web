/// Generated by terra, DO NOT MODIFY BY HAND.

import * as NATIVE_RTC from '@iris/native-rtc-binding';
import {
  CallIrisApiResult,
  EventParam,
  IrisApiEngine,
  IrisCore,
} from 'iris-web-core';

import { initIrisRtc } from '../../src/index';
import { IrisRtcEngine } from '../engine/IrisRtcEngine';

const bindingAPI = require('../../src/binding/IAgoraMediaEngineDispatch');

let apiEnginePtr: IrisApiEngine;
let irisRtcEngine: IrisRtcEngine;
beforeAll(async () => {
  apiEnginePtr = IrisCore.createIrisApiEngine();
  initIrisRtc(apiEnginePtr);
  irisRtcEngine = apiEnginePtr['apiInterceptors'][0];
  irisRtcEngine.implHelper.createAudioTrack = jest.fn();
  let nParam = {
    context: 'test',
  };
  let apiParam = new EventParam(
    'RtcEngine_initialize',
    JSON.stringify(nParam),
    0,
    '',
    ['test'],
    [],
    1
  );
  await IrisCore.callIrisApi(apiEnginePtr, apiParam);
});

afterAll(() => {
  IrisCore.disposeIrisApiEngine(apiEnginePtr);
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('IMediaEngine', () => {
  test('registerAudioFrameObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'registerAudioFrameObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_registerAudioFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .registerAudioFrameObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerVideoFrameObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'registerVideoFrameObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_registerVideoFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .registerVideoFrameObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('registerVideoEncodedFrameObserver impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'registerVideoEncodedFrameObserver'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      observer: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_registerVideoEncodedFrameObserver',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .registerVideoEncodedFrameObserver
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pushAudioFrame impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'pushAudioFrame'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      frame: 'test',
      trackId: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_pushAudioFrame',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl.pushAudioFrame
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pullAudioFrame impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'pullAudioFrame'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      frame: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_pullAudioFrame',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl.pullAudioFrame
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setExternalVideoSource parameter', async () => {
    let nParam = {
      enabled: undefined,
      useTexture: undefined,
      sourceType: undefined,
      encodedVideoOption: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new EventParam(
            'MediaEngine_setExternalVideoSource',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setExternalVideoSource impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'setExternalVideoSource'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      useTexture: 'test',
      sourceType: 'test',
      encodedVideoOption: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_setExternalVideoSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .setExternalVideoSource
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .setExternalVideoSource
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('setExternalAudioSource impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'setExternalAudioSource'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      sampleRate: 'test',
      channels: 'test',
      localPlayback: 'test',
      publish: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_setExternalAudioSource',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .setExternalAudioSource
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createCustomAudioTrack impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'createCustomAudioTrack'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackType: 'test',
      config: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_createCustomAudioTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .createCustomAudioTrack
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('destroyCustomAudioTrack impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'destroyCustomAudioTrack'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_destroyCustomAudioTrack',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .destroyCustomAudioTrack
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setExternalAudioSink impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'setExternalAudioSink'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      sampleRate: 'test',
      channels: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_setExternalAudioSink',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .setExternalAudioSink
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableCustomAudioLocalPlayback impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'enableCustomAudioLocalPlayback'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      trackId: 'test',
      enabled: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_enableCustomAudioLocalPlayback',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .enableCustomAudioLocalPlayback
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pushVideoFrame parameter', async () => {
    let nParam = {
      frame: undefined,
      videoTrackId: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new EventParam(
            'MediaEngine_pushVideoFrame',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('pushVideoFrame impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'pushVideoFrame'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      frame: 'test',
      videoTrackId: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_pushVideoFrame',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl.pushVideoFrame
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl.pushVideoFrame
    ).toBeCalledWith('test', 'test');
  });

  test('pushEncodedVideoImage impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'pushEncodedVideoImage'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      imageBuffer: 'test',
      length: 'test',
      videoEncodedFrameInfo: 'test',
      videoTrackId: 'test',
    };
    let apiParam = new EventParam(
      'MediaEngine_pushEncodedVideoImage',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl
        .pushEncodedVideoImage
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('release impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl,
        'release'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {};
    let apiParam = new EventParam(
      'MediaEngine_release',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('MediaEngine')._impl.release
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});

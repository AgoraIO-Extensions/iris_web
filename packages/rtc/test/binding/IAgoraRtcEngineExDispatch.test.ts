/// Generated by terra, DO NOT MODIFY BY HAND.

import * as NATIVE_RTC from '@iris/native-rtc';
import { CallIrisApiResult, IrisApiEngine, IrisCore } from 'iris-web-core';

import { IrisWebRtc } from '../../src/IrisRtcApi';
import * as bufferExtensions from '../../src/extensions/CallApiBufferExtensions';
import { IrisRtcEngine } from '../engine/IrisRtcEngine';

const bindingAPI = require('../../src/binding/IAgoraRtcEngineExDispatch');

let apiEnginePtr: IrisApiEngine;
let irisRtcEngine: IrisRtcEngine;
beforeAll(async () => {
  apiEnginePtr = IrisCore.createIrisApiEngine();
  IrisWebRtc.initIrisRtc(apiEnginePtr);
  irisRtcEngine = apiEnginePtr['apiInterceptors'][0];
  irisRtcEngine.implHelper.createMicrophoneAudioTrack = jest.fn();
  let nParam = {
    context: 'test',
  };
  let apiParam = new IrisCore.EventParam(
    'RtcEngine_initialize',
    JSON.stringify(nParam),
    0,
    '',
    ['test'],
    [],
    1
  );
  await IrisCore.callIrisApi(apiEnginePtr, apiParam);
});

afterAll(() => {
  IrisCore.disposeIrisApiEngine(apiEnginePtr);
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('IRtcEngineEx', () => {
  test('RtcEngineEx_joinChannelEx parameter', async () => {
    let nParam = {
      token: undefined,
      connection: undefined,
      options: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_joinChannelEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('token is undefined');
    }
    //@ts-ignore
    nParam.token = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_joinChannelEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_joinChannelEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
  });

  test('RtcEngineEx_joinChannelEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'joinChannelEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      connection: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_joinChannelEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.joinChannelEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.joinChannelEx
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('RtcEngineEx_leaveChannelEx parameter', async () => {
    let nParam = {
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_leaveChannelEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_leaveChannelEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'leaveChannelEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_leaveChannelEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.leaveChannelEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.leaveChannelEx
    ).toBeCalledWith('test');
  });

  test('RtcEngineEx_leaveChannelEx2 parameter', async () => {
    let nParam = {
      connection: undefined,
      options: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_leaveChannelEx2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_leaveChannelEx2',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
  });

  test('RtcEngineEx_leaveChannelEx2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'leaveChannelEx2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_leaveChannelEx2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.leaveChannelEx2
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.leaveChannelEx2
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngineEx_updateChannelMediaOptionsEx parameter', async () => {
    let nParam = {
      options: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_updateChannelMediaOptionsEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('options is undefined');
    }
    //@ts-ignore
    nParam.options = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_updateChannelMediaOptionsEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_updateChannelMediaOptionsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'updateChannelMediaOptionsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_updateChannelMediaOptionsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .updateChannelMediaOptionsEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .updateChannelMediaOptionsEx
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngineEx_setVideoEncoderConfigurationEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setVideoEncoderConfigurationEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setVideoEncoderConfigurationEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setupRemoteVideoEx parameter', async () => {
    let nParam = {
      canvas: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_setupRemoteVideoEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('canvas is undefined');
    }
    //@ts-ignore
    nParam.canvas = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_setupRemoteVideoEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_setupRemoteVideoEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setupRemoteVideoEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      canvas: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setupRemoteVideoEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setupRemoteVideoEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setupRemoteVideoEx
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngineEx_muteRemoteAudioStreamEx parameter', async () => {
    let nParam = {
      uid: undefined,
      mute: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteRemoteAudioStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteRemoteAudioStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteRemoteAudioStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_muteRemoteAudioStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteRemoteAudioStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteRemoteAudioStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteRemoteAudioStreamEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteRemoteAudioStreamEx
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('RtcEngineEx_muteRemoteVideoStreamEx parameter', async () => {
    let nParam = {
      uid: undefined,
      mute: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteRemoteVideoStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteRemoteVideoStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteRemoteVideoStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_muteRemoteVideoStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteRemoteVideoStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteRemoteVideoStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteRemoteVideoStreamEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteRemoteVideoStreamEx
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('RtcEngineEx_setRemoteVideoStreamTypeEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      streamType: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteVideoStreamTypeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setRemoteVideoStreamTypeEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_muteLocalAudioStreamEx parameter', async () => {
    let nParam = {
      mute: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteLocalAudioStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteLocalAudioStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_muteLocalAudioStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteLocalAudioStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteLocalAudioStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteLocalAudioStreamEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteLocalAudioStreamEx
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngineEx_muteLocalVideoStreamEx parameter', async () => {
    let nParam = {
      mute: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteLocalVideoStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteLocalVideoStreamEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_muteLocalVideoStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteLocalVideoStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteLocalVideoStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteLocalVideoStreamEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteLocalVideoStreamEx
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngineEx_muteAllRemoteAudioStreamsEx parameter', async () => {
    let nParam = {
      mute: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteAllRemoteAudioStreamsEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteAllRemoteAudioStreamsEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_muteAllRemoteAudioStreamsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteAllRemoteAudioStreamsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteAllRemoteAudioStreamsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteAllRemoteAudioStreamsEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteAllRemoteAudioStreamsEx
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngineEx_muteAllRemoteVideoStreamsEx parameter', async () => {
    let nParam = {
      mute: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteAllRemoteVideoStreamsEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mute is undefined');
    }
    //@ts-ignore
    nParam.mute = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_muteAllRemoteVideoStreamsEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_muteAllRemoteVideoStreamsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteAllRemoteVideoStreamsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteAllRemoteVideoStreamsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteAllRemoteVideoStreamsEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteAllRemoteVideoStreamsEx
    ).toBeCalledWith('test', 'test');
  });

  test('RtcEngineEx_setSubscribeAudioBlocklistEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeAudioBlocklistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setSubscribeAudioBlocklistEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setSubscribeAudioAllowlistEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeAudioAllowlistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setSubscribeAudioAllowlistEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setSubscribeVideoBlocklistEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeVideoBlocklistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setSubscribeVideoBlocklistEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setSubscribeVideoAllowlistEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeVideoAllowlistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setSubscribeVideoAllowlistEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setRemoteVideoSubscriptionOptionsEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      options: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteVideoSubscriptionOptionsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setRemoteVideoSubscriptionOptionsEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setRemoteVoicePositionEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      pan: 'test',
      gain: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteVoicePositionEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setRemoteVoicePositionEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setRemoteUserSpatialAudioParamsEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      params: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteUserSpatialAudioParamsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setRemoteUserSpatialAudioParamsEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setRemoteRenderModeEx parameter', async () => {
    let nParam = {
      uid: undefined,
      renderMode: undefined,
      mirrorMode: undefined,
      connection: undefined,
    };
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_setRemoteRenderModeEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('uid is undefined');
    }
    //@ts-ignore
    nParam.uid = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_setRemoteRenderModeEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('renderMode is undefined');
    }
    //@ts-ignore
    nParam.renderMode = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_setRemoteRenderModeEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('mirrorMode is undefined');
    }
    //@ts-ignore
    nParam.mirrorMode = 'test';
    try {
      await IrisCore.callIrisApi(
        apiEnginePtr,
        new IrisCore.EventParam(
          'RtcEngineEx_setRemoteRenderModeEx',
          JSON.stringify(nParam),
          0,
          '',
          ['test'],
          [],
          1
        )
      );
    } catch (e) {
      expect(e).toEqual('connection is undefined');
    }
    //@ts-ignore
    nParam.connection = 'test';
  });

  test('RtcEngineEx_setRemoteRenderModeEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setRemoteRenderModeEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      renderMode: 'test',
      mirrorMode: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteRenderModeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setRemoteRenderModeEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setRemoteRenderModeEx
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('RtcEngineEx_enableLoopbackRecordingEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      enabled: 'test',
      deviceName: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableLoopbackRecordingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.enableLoopbackRecordingEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_adjustRecordingSignalVolumeEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_adjustRecordingSignalVolumeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.adjustRecordingSignalVolumeEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_muteRecordingSignalEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteRecordingSignalEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.muteRecordingSignalEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_adjustUserPlaybackSignalVolumeEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      volume: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_adjustUserPlaybackSignalVolumeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.adjustUserPlaybackSignalVolumeEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_getConnectionStateEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_getConnectionStateEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.getConnectionStateEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_enableEncryptionEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableEncryptionEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.enableEncryptionEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_createDataStreamEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      reliable: 'test',
      ordered: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_createDataStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.createDataStreamEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_createDataStreamEx2 impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_createDataStreamEx2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.createDataStreamEx2
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_sendStreamMessageEx parameter', async () => {
    let nParam = {
      streamId: 'test',
      data: 'test',
      length: 'test',
      connection: 'test',
    };
    jest.spyOn(bufferExtensions, 'callApiBufferExtension');
    await IrisCore.callIrisApi(
      apiEnginePtr,
      new IrisCore.EventParam(
        'RtcEngineEx_sendStreamMessageEx',
        JSON.stringify(nParam),
        0,
        '',
        ['test'],
        [],
        1
      )
    );
    expect(bufferExtensions.callApiBufferExtension).toBeCalledTimes(1);
  });

  test('RtcEngineEx_sendStreamMessageEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'sendStreamMessageEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      data: 'test',
      length: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_sendStreamMessageEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .sendStreamMessageEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .sendStreamMessageEx
    ).toBeCalledWith('test', 'test', 'test', 'test');
  });

  test('RtcEngineEx_addVideoWatermarkEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      watermarkUrl: 'test',
      options: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_addVideoWatermarkEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.addVideoWatermarkEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_clearVideoWatermarkEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_clearVideoWatermarkEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.clearVideoWatermarkEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_sendCustomReportMessageEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      id: 'test',
      category: 'test',
      event: 'test',
      label: 'test',
      value: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_sendCustomReportMessageEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.sendCustomReportMessageEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_enableAudioVolumeIndicationEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      interval: 'test',
      smooth: 'test',
      reportVad: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableAudioVolumeIndicationEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.enableAudioVolumeIndicationEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_startRtmpStreamWithoutTranscodingEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startRtmpStreamWithoutTranscodingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.startRtmpStreamWithoutTranscodingEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_startRtmpStreamWithTranscodingEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      transcoding: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startRtmpStreamWithTranscodingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.startRtmpStreamWithTranscodingEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_updateRtmpTranscodingEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      transcoding: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_updateRtmpTranscodingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.updateRtmpTranscodingEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_stopRtmpStreamEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_stopRtmpStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl?.stopRtmpStreamEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_startOrUpdateChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startOrUpdateChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.startOrUpdateChannelMediaRelayEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_startChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.startChannelMediaRelayEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_updateChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_updateChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.updateChannelMediaRelayEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_stopChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_stopChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.stopChannelMediaRelayEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_pauseAllChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_pauseAllChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.pauseAllChannelMediaRelayEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_resumeAllChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_resumeAllChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.resumeAllChannelMediaRelayEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_getUserInfoByUserAccountEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      userAccount: 'test',
      userInfo: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_getUserInfoByUserAccountEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.getUserInfoByUserAccountEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_getUserInfoByUidEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      userInfo: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_getUserInfoByUidEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.getUserInfoByUidEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_enableDualStreamModeEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      streamConfig: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableDualStreamModeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.enableDualStreamModeEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setDualStreamModeEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
      streamConfig: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setDualStreamModeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setDualStreamModeEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_setHighPriorityUserListEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNum: 'test',
      option: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setHighPriorityUserListEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.setHighPriorityUserListEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_takeSnapshotEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      uid: 'test',
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_takeSnapshotEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl?.takeSnapshotEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_enableContentInspectEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableContentInspectEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.enableContentInspectEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('RtcEngineEx_startMediaRenderingTracingEx impl call', async () => {
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startMediaRenderingTracingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        ?.startMediaRenderingTracingEx
    ).toBeUndefined();
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});

/// Generated by terra, DO NOT MODIFY BY HAND.

import * as NATIVE_RTC from '@iris/native-rtc-binding';
import { CallIrisApiResult, IrisApiEngine, IrisCore } from 'iris-web-core';

import { initIrisRtc } from '../../src/index';
import { IrisRtcEngine } from '../engine/IrisRtcEngine';

const bindingAPI = require('../../src/binding/IAgoraRtcEngineExDispatch');

let apiEnginePtr: IrisApiEngine;
let irisRtcEngine: IrisRtcEngine;
beforeAll(async () => {
  apiEnginePtr = IrisCore.createIrisApiEngine();
  initIrisRtc(apiEnginePtr);
  irisRtcEngine = apiEnginePtr['apiInterceptors'][0];
  irisRtcEngine.implHelper.createAudioTrack = jest.fn();
  let nParam = {
    context: 'test',
  };
  let apiParam = new IrisCore.EventParam(
    'RtcEngine_initialize',
    JSON.stringify(nParam),
    0,
    '',
    ['test'],
    [],
    1
  );
  await IrisCore.callIrisApi(apiEnginePtr, apiParam);
});

afterAll(() => {
  IrisCore.disposeIrisApiEngine(apiEnginePtr);
});

afterEach(() => {
  jest.clearAllMocks();
});

describe('IRtcEngineEventHandlerEx', () => {
  test('onJoinChannelSuccessEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onJoinChannelSuccessEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onJoinChannelSuccessEx');
  });
  test('onRejoinChannelSuccessEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRejoinChannelSuccessEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioQualityEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onAudioQualityEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onAudioVolumeIndicationEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onAudioVolumeIndicationEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onAudioVolumeIndicationEx');
  });
  test('onLeaveChannelEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onLeaveChannelEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onLeaveChannelEx');
  });
  test('onRtcStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRtcStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onNetworkQualityEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onNetworkQualityEx(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onIntraRequestReceivedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onIntraRequestReceivedEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstRemoteVideoDecodedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onFirstRemoteVideoDecodedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onFirstRemoteVideoDecodedEx');
  });
  test('onVideoSizeChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoSizeChangedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteVideoStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoStateChangedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstRemoteVideoFrameEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onFirstRemoteVideoFrameEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onFirstRemoteVideoFrameEx');
  });
  test('onUserJoinedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onUserJoinedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onUserJoinedEx');
  });
  test('onUserOfflineEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onUserOfflineEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onUserOfflineEx');
  });
  test('onUserMuteAudioEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onUserMuteAudioEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onUserMuteAudioEx');
  });
  test('onUserMuteVideoEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onUserMuteVideoEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onUserMuteVideoEx');
  });
  test('onUserEnableVideoEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserEnableVideoEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserEnableLocalVideoEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onUserEnableLocalVideoEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onUserEnableLocalVideoEx');
  });
  test('onUserStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onUserStateChangedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onUserStateChangedEx');
  });
  test('onLocalAudioStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalAudioStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteAudioStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteVideoStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoStatsEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onConnectionLostEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onConnectionLostEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onConnectionLostEx');
  });
  test('onConnectionInterruptedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onConnectionInterruptedEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onConnectionInterruptedEx');
  });
  test('onConnectionBannedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onConnectionBannedEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onConnectionBannedEx');
  });
  test('onStreamMessageEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onStreamMessageEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onStreamMessageErrorEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onStreamMessageErrorEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRequestTokenEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onRequestTokenEx(undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onRequestTokenEx');
  });
  test('onLicenseValidationFailureEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLicenseValidationFailureEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onTokenPrivilegeWillExpireEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onTokenPrivilegeWillExpireEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith(
      'onTokenPrivilegeWillExpireEx'
    );
  });
  test('onFirstLocalAudioFramePublishedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onFirstLocalAudioFramePublishedEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onFirstRemoteAudioFrameEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onFirstRemoteAudioFrameEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onFirstRemoteAudioFrameEx');
  });
  test('onFirstRemoteAudioDecodedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onFirstRemoteAudioDecodedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onFirstRemoteAudioDecodedEx');
  });
  test('onLocalAudioStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onLocalAudioStateChangedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteAudioStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioStateChangedEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onActiveSpeakerEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onActiveSpeakerEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onClientRoleChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onClientRoleChangedEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onClientRoleChangeFailedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onClientRoleChangeFailedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteAudioTransportStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteAudioTransportStatsEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onRemoteVideoTransportStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onRemoteVideoTransportStatsEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onConnectionStateChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onConnectionStateChangedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onConnectionStateChangedEx');
  });
  test('onWlAccMessageEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccMessageEx(undefined, undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onWlAccStatsEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onWlAccStatsEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onNetworkTypeChangedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onNetworkTypeChangedEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onEncryptionErrorEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    eventHandler.onEncryptionErrorEx(undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledTimes(1);
    expect(eventHandler.eventKey).toBeCalledWith('onEncryptionErrorEx');
  });
  test('onUploadLogResultEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUploadLogResultEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onUserAccountUpdatedEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onUserAccountUpdatedEx(undefined, undefined, undefined);
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onSnapshotTakenEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onSnapshotTakenEx(
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
  test('onVideoRenderingTracingResultEx impl call', async () => {
    let eventHandler = new bindingAPI.IRtcEngineEventHandlerEx(irisRtcEngine);
    jest.spyOn(eventHandler._engine.irisEventHandlerManager, 'notifyEvent');
    jest.spyOn(eventHandler, 'eventKey');
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    eventHandler.onVideoRenderingTracingResultEx(
      undefined,
      undefined,
      undefined,
      undefined
    );
    expect(
      eventHandler._engine.irisEventHandlerManager.notifyEvent
    ).toBeCalledTimes(0);
    expect(eventHandler.eventKey).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
describe('IRtcEngineEx', () => {
  test('joinChannelEx parameter', async () => {
    let nParam = {
      token: undefined,
      connection: undefined,
      options: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngineEx_joinChannelEx',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('joinChannelEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'joinChannelEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      token: 'test',
      connection: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_joinChannelEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.joinChannelEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.joinChannelEx
    ).toBeCalledWith('test', 'test', 'test');
  });

  test('leaveChannelEx parameter', async () => {
    let nParam = {
      connection: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngineEx_leaveChannelEx',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('leaveChannelEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'leaveChannelEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_leaveChannelEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.leaveChannelEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.leaveChannelEx
    ).toBeCalledWith('test');
  });

  test('leaveChannelEx2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'leaveChannelEx2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      options: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_leaveChannelEx2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.leaveChannelEx2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateChannelMediaOptionsEx parameter', async () => {
    let nParam = {
      options: undefined,
      connection: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngineEx_updateChannelMediaOptionsEx',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('updateChannelMediaOptionsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'updateChannelMediaOptionsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      options: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_updateChannelMediaOptionsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .updateChannelMediaOptionsEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .updateChannelMediaOptionsEx
    ).toBeCalledWith('test', 'test');
  });

  test('setVideoEncoderConfigurationEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setVideoEncoderConfigurationEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      config: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setVideoEncoderConfigurationEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setVideoEncoderConfigurationEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setupRemoteVideoEx parameter', async () => {
    let nParam = {
      canvas: undefined,
      connection: undefined,
    };
    for (let i in nParam) {
      try {
        await IrisCore.callIrisApi(
          apiEnginePtr,
          new IrisCore.EventParam(
            'RtcEngineEx_setupRemoteVideoEx',
            JSON.stringify(nParam),
            0,
            '',
            ['test'],
            [],
            1
          )
        );
      } catch (e) {
        expect(e).toEqual(i + ' is undefined');
      }
      nParam[i] = 'test';
    }
  });

  test('setupRemoteVideoEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setupRemoteVideoEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      canvas: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setupRemoteVideoEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setupRemoteVideoEx
    ).toBeCalledTimes(1);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setupRemoteVideoEx
    ).toBeCalledWith('test', 'test');
  });

  test('muteRemoteAudioStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteRemoteAudioStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteRemoteAudioStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteRemoteAudioStreamEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteRemoteVideoStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteRemoteVideoStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteRemoteVideoStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteRemoteVideoStreamEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteVideoStreamTypeEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setRemoteVideoStreamTypeEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      streamType: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteVideoStreamTypeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setRemoteVideoStreamTypeEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteLocalAudioStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteLocalAudioStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteLocalAudioStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteLocalAudioStreamEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteLocalVideoStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteLocalVideoStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteLocalVideoStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteLocalVideoStreamEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteAllRemoteAudioStreamsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteAllRemoteAudioStreamsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteAllRemoteAudioStreamsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteAllRemoteAudioStreamsEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteAllRemoteVideoStreamsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteAllRemoteVideoStreamsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteAllRemoteVideoStreamsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteAllRemoteVideoStreamsEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeAudioBlocklistEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setSubscribeAudioBlocklistEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeAudioBlocklistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setSubscribeAudioBlocklistEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeAudioAllowlistEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setSubscribeAudioAllowlistEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeAudioAllowlistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setSubscribeAudioAllowlistEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeVideoBlocklistEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setSubscribeVideoBlocklistEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeVideoBlocklistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setSubscribeVideoBlocklistEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setSubscribeVideoAllowlistEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setSubscribeVideoAllowlistEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNumber: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setSubscribeVideoAllowlistEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setSubscribeVideoAllowlistEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteVideoSubscriptionOptionsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setRemoteVideoSubscriptionOptionsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      options: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteVideoSubscriptionOptionsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setRemoteVideoSubscriptionOptionsEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteVoicePositionEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setRemoteVoicePositionEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      pan: 'test',
      gain: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteVoicePositionEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setRemoteVoicePositionEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteUserSpatialAudioParamsEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setRemoteUserSpatialAudioParamsEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      params: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteUserSpatialAudioParamsEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setRemoteUserSpatialAudioParamsEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setRemoteRenderModeEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setRemoteRenderModeEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      renderMode: 'test',
      mirrorMode: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setRemoteRenderModeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setRemoteRenderModeEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableLoopbackRecordingEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'enableLoopbackRecordingEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      enabled: 'test',
      deviceName: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableLoopbackRecordingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .enableLoopbackRecordingEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustRecordingSignalVolumeEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'adjustRecordingSignalVolumeEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      volume: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_adjustRecordingSignalVolumeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .adjustRecordingSignalVolumeEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('muteRecordingSignalEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'muteRecordingSignalEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mute: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_muteRecordingSignalEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .muteRecordingSignalEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('adjustUserPlaybackSignalVolumeEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'adjustUserPlaybackSignalVolumeEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      volume: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_adjustUserPlaybackSignalVolumeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .adjustUserPlaybackSignalVolumeEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getConnectionStateEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'getConnectionStateEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_getConnectionStateEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .getConnectionStateEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableEncryptionEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'enableEncryptionEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      enabled: 'test',
      config: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableEncryptionEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .enableEncryptionEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createDataStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'createDataStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      reliable: 'test',
      ordered: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_createDataStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .createDataStreamEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('createDataStreamEx2 impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'createDataStreamEx2'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      config: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_createDataStreamEx2',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .createDataStreamEx2
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('sendStreamMessageEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'sendStreamMessageEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      streamId: 'test',
      data: 'test',
      length: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_sendStreamMessageEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .sendStreamMessageEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('addVideoWatermarkEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'addVideoWatermarkEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      watermarkUrl: 'test',
      options: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_addVideoWatermarkEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .addVideoWatermarkEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('clearVideoWatermarkEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'clearVideoWatermarkEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_clearVideoWatermarkEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .clearVideoWatermarkEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('sendCustomReportMessageEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'sendCustomReportMessageEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      id: 'test',
      category: 'test',
      event: 'test',
      label: 'test',
      value: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_sendCustomReportMessageEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .sendCustomReportMessageEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableAudioVolumeIndicationEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'enableAudioVolumeIndicationEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      interval: 'test',
      smooth: 'test',
      reportVad: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableAudioVolumeIndicationEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .enableAudioVolumeIndicationEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startRtmpStreamWithoutTranscodingEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'startRtmpStreamWithoutTranscodingEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startRtmpStreamWithoutTranscodingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .startRtmpStreamWithoutTranscodingEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startRtmpStreamWithTranscodingEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'startRtmpStreamWithTranscodingEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      transcoding: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startRtmpStreamWithTranscodingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .startRtmpStreamWithTranscodingEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateRtmpTranscodingEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'updateRtmpTranscodingEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      transcoding: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_updateRtmpTranscodingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .updateRtmpTranscodingEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopRtmpStreamEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'stopRtmpStreamEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      url: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_stopRtmpStreamEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.stopRtmpStreamEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startOrUpdateChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'startOrUpdateChannelMediaRelayEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startOrUpdateChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .startOrUpdateChannelMediaRelayEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'startChannelMediaRelayEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .startChannelMediaRelayEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('updateChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'updateChannelMediaRelayEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      configuration: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_updateChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .updateChannelMediaRelayEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('stopChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'stopChannelMediaRelayEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_stopChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .stopChannelMediaRelayEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('pauseAllChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'pauseAllChannelMediaRelayEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_pauseAllChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .pauseAllChannelMediaRelayEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('resumeAllChannelMediaRelayEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'resumeAllChannelMediaRelayEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_resumeAllChannelMediaRelayEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .resumeAllChannelMediaRelayEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getUserInfoByUserAccountEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'getUserInfoByUserAccountEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      userAccount: 'test',
      userInfo: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_getUserInfoByUserAccountEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .getUserInfoByUserAccountEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('getUserInfoByUidEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'getUserInfoByUidEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uid: 'test',
      userInfo: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_getUserInfoByUidEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .getUserInfoByUidEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableDualStreamModeEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'enableDualStreamModeEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      streamConfig: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableDualStreamModeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .enableDualStreamModeEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setDualStreamModeEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setDualStreamModeEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      mode: 'test',
      streamConfig: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setDualStreamModeEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setDualStreamModeEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('setHighPriorityUserListEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'setHighPriorityUserListEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      uidList: 'test',
      uidNum: 'test',
      option: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_setHighPriorityUserListEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .setHighPriorityUserListEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('takeSnapshotEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'takeSnapshotEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
      uid: 'test',
      filePath: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_takeSnapshotEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl.takeSnapshotEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('enableContentInspectEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'enableContentInspectEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      enabled: 'test',
      config: 'test',
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_enableContentInspectEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .enableContentInspectEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });

  test('startMediaRenderingTracingEx impl call', async () => {
    jest
      .spyOn(
        irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl,
        'startMediaRenderingTracingEx'
      )
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    jest
      .spyOn(irisRtcEngine, 'returnResult')
      .mockResolvedValue(new CallIrisApiResult(0, ''));
    let nParam = {
      connection: 'test',
    };
    let apiParam = new IrisCore.EventParam(
      'RtcEngineEx_startMediaRenderingTracingEx',
      JSON.stringify(nParam),
      0,
      '',
      ['test'],
      [],
      1
    );
    await IrisCore.callIrisApi(apiEnginePtr, apiParam);
    expect(
      irisRtcEngine.implDispatchesMap.get('RtcEngineEx')._impl
        .startMediaRenderingTracingEx
    ).toBeCalledTimes(0);
    expect(irisRtcEngine.returnResult).toBeCalledTimes(1);
    expect(irisRtcEngine.returnResult).toBeCalledWith(
      false,
      -NATIVE_RTC.ERROR_CODE_TYPE.ERR_NOT_SUPPORTED
    );
  });
});
